Alfredo M. Funada
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
2
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
3
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
4
IMPLEMENTAÇÃO
nan
DIFICULDADES
Enfrentei alguns problemas por conhecer pouco sobre o java, mas também não tinha idéia do que precisava estudar antes, então comecei a tarefa e quando foi aparecendo as dificuldades fui buscando as informações.


TASK 
5
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
6
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
7
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
8
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
9
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
10
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


============================================
Ana Flavia Lemos
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Criei a classe FieldMapperContainer para armazenar as informações sobre a anotação isParameterPresent e a classe ClassMapperContainer para capturar todos os campos anotados com @IsParameterPresent. Na classe ParameterMapper com base nos metadados coletados eu validei o comando de acordo com as regras. 
DIFICULDADES
Não encontrei dificuldades na implementação desta tarefa.


TASK 
2
IMPLEMENTAÇÃO
Criei uma nova classe FieldTextValueMapperContainer responsável por manter os metadados da anotação TextValue e completei a leitura dos valores da linha de comando na classe ParameterMapper.
DIFICULDADES
Não encontrei dificuldades para implementar esta tarefa.


TASK 
3
IMPLEMENTAÇÃO
Coletei as informações da anotação @Mandatory na classe FieldTextValueContainer e completei a classe ParamMapper para validar a existência ou não dos parâmetros obrigatório.
DIFICULDADES
Não encontrei dificuldades para implementar essa tarefa.


TASK 
4
IMPLEMENTAÇÃO
Criei a classe FieldNumericValue para manter os metadados relacionados a anotação @NumericValue. Completei o processamento das anotações na classe ParamMapper com as regras relacionadas ao uso da anotação @NumericValue.
DIFICULDADES
Não encontrei dificuldade para implementar esta tarefa.


TASK 
5
IMPLEMENTAÇÃO
Implementei as regras de validação utilizando as anotações @NeedsToHave, @Notnull, @MinValue e @MaxValue. O processando dos comando foi implementado na classe ParamMapper
DIFICULDADES
Não encontrei dificuldades para executar esta tarefa.


TASK 
6
IMPLEMENTAÇÃO
Implementei as regras de validação utilizando as anotações @NeedsToHave e @MinValue. O processamento dos valores na linha de comando eu implementei na classe ParamMapper.
DIFICULDADES
Não encontrei dificuldade para executar essa tarefa.


TASK 
7
IMPLEMENTAÇÃO
Implementei as validações de uso da anotação utilizando a anotação @Prohibits. Para processar as anotações dentro da classe composta, eu extrai os processamentos para um método que passou a ser chamado recursivamente para processar as classes compostas como containers.
DIFICULDADES
Não encontrei dificuldade para executar essa tarefa.


TASK 
8
IMPLEMENTAÇÃO
Na classe ClassMapperContainer registrei o processamento de todos os campos de acordo com os metadados anotados na classe FieldCustomAnnotationMapperContainer. Nas ultima classe eu coletei a anotação presente no field, o nome do parametro e os dados processados pelo ParameterAnnotationProcessor.  Por fim, na classe ParamMapper implementei a logica de processamento da linha de comando.
DIFICULDADES
O uso das anotações para extensão do modelo de metadados é bem pouco trivial. Entrei um pouco de dificuldade para compreender a lógica mesmo assistindo aos videos repetidas vezes.


TASK 
9
IMPLEMENTAÇÃO
Para validar o uso da anotação implementei um novo validador chamado GenericTypeValidator associado a classe ValidGenericTypes para verificar o uso correto dos tipos dentro do List genérico. O processamento da linha de comando implementei na classe ParamMapper.
DIFICULDADES
Não encontrei dificuldades para implementar esta tarefa em termos de recursos do framework. Porém tive alguns problemas para implementar o processando da linha de comando.


TASK 
10
IMPLEMENTAÇÃO
Implementei esta tarefa de modo bem similar a implementação das tarefas 1 e 2, processando os metadados na classe FieldDateValueContainer e ClassMapperContainer e processando a linha de comando na classe ParamMapper.
DIFICULDADES
Não encontrei dificuldade para implementar essa tarefa.


============================================
Daniel Mário de Lima
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Os metadados são salvos em Container.parameters (HashMap) e verificados um a um pela existência do parâmetro no vetor da linha de comando.
DIFICULDADES
Me confundi brevemente entre BeanUtils e a API de reflexão padrão.


TASK 
2
IMPLEMENTAÇÃO
Separei a verificação da anotação em duas classes auxiliares, uma para Boolean e outra para String, e coloquei a leitura da linha de comando em um objeto com um StringBuffer opcional.
DIFICULDADES
Minha principal dificuldade foi decidir quais objetos seriam responsáveis pela leitura e armazenamento de cada informação necessária para ler os valores. No fim, deixei o mapa de campos e parâmetros no ParamMapperContainer e o parsing da linha de comando no ParamMapper.


TASK 
3
IMPLEMENTAÇÃO
Generalizei as classes de processamento de parâmetros para qualquer tipo de anotação, criando uma lista de comandos para processar cada anotação de cada atributo da classe, e então adicionei um comando para processar a anotação Mandatory.
DIFICULDADES
Nessa tarefa o processo fluiu de forma mais direta, mas ainda é percebido algum atrito em decidir mudanças arquiteturais.


TASK 
4
IMPLEMENTAÇÃO
Criei novo processador de Anotações para o valor Numérico com a lógica necessária e adicionei como campo aceito em Mandatory e ParamMapperContainer.
DIFICULDADES
Tive que usar a API de reflexão diretamente para conseguir atribuir null como valor default, pois o comportamento padrão do BeanUtils converte nulls automaticamente para zero no caso de valores numéricos.


TASK 
5
IMPLEMENTAÇÃO
Segui os mesmos passos anteriores, criei novos AnnotationProcessors chamados de LengthParameter e FormatParameter que carregam e processam os dados, fazendo as verificações e lançando as exceções solicitadas.
DIFICULDADES
Essa tarefa foi bem direta, não tive muito trabalho.


TASK 
6
IMPLEMENTAÇÃO
Adicionei os processadores referentes às anotações, e aproveitei para refatorar um método da interface dos refatoradores, já que era uma funcionalidade repetida em dois métodos separados. 
DIFICULDADES
Nenhuma, tudo correu bem.


TASK 
7
IMPLEMENTAÇÃO
Utilizei a própria API do ParamMapper para criar mapeadores de objetos recursivamente ao encontrar CompositeParameters.
DIFICULDADES
Esta tarefa foi surpreendentemente simples, já que os outros requisitos da tarefa não haviam sido implementados explicitamente.


TASK 
8
IMPLEMENTAÇÃO
Fiz uma grande refatoração para adaptar a estrutura de AnnotationProcessor à API solicitada, mudando assinaturas de métodos e modelo de dados do ParamMapperContainer.
DIFICULDADES
Como foi uma refatoração grande (cirurgia com rifle), foi bem mais trabalhoso que as outras tarefas, onde eu tinha que parar constantemente para relembrar a arquitetura e seguir um checklist das mudanças necessárias.


TASK 
9
IMPLEMENTAÇÃO
Verificando o tipo e subtipo (genérico) do field em StringParameter e NumberParameter (AnnotationProcessors), instanciando os objetos List antes de atribuí-los ao objeto.
DIFICULDADES
Me confundi um pouco com a API de reflexão em genéricos, mas nada muito grave.


TASK 
10
IMPLEMENTAÇÃO
Criei a AnnotationProcessor para Dates, checando o tipo do campo e validade do formato, retornando exceções nos casos inválidos.
DIFICULDADES
A refatoração da tarefa 8 foi bem trabalhosa, mas fez as tarefas 9 e 10 serem muito mais simples de se implementar. Se não me engano, a tarefa 10 foi a mais rápida dentre todas.


============================================
David Buzatto
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Implementei utilizando a IDE NetBeans, visto que o Eclipse estava dando muitos erros. Acredito que na cópia dos arquivos prontos do NetBeans para o Eclipse eu talvez tenhe entendido o motivo dos erros do Eclipse. A próxima tarefa tentarei fazer no Eclipse.
DIFICULDADES
Gostei da API Esfinge, mas ainda não consigo decidir se é melhor usá-la ou ir direto com a API de reflexão do Java. Por enquanto, continuaria com a API do Java, visto que parece ser mais direta ao ponto, ao invés de ter que ficar criando classes de container com n anotações.


TASK 
2
IMPLEMENTAÇÃO
Implementei no Eclipse, foi tudo bem. Realizei os testes um por um até tudo estar ok, além de usar diversos printlns para verificar alguns valores. Fiz os testes inicial e da tarefa 1, que ficaram quebrados, ajustei todo o código até tudo passar. Está tudo ok.
DIFICULDADES
nan


TASK 
3
IMPLEMENTAÇÃO
Fiz a implementação usando tanto a API do Java quanto a Esfinge.
DIFICULDADES
nan


TASK 
4
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
5
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
6
IMPLEMENTAÇÃO
De forma parecida com a tarefa das anotações para texto. Parei um pouco para dar uma refatorada no código, criando uma classe para abrigar diversos métodos estáticos para o algoritmo de mapeamento.
DIFICULDADES
nan


TASK 
7
IMPLEMENTAÇÃO
Adaptação do algoritmo para ser recursivo possibilitando o tratamento de @CompositeParameter
DIFICULDADES
nan


TASK 
8
IMPLEMENTAÇÃO
Utilizei a API de reflexão do Java.
DIFICULDADES
Foram feitas diversas tentativas usando o Esfinge Metadata, mas infelizmente não consegui fazer o mecanismo de processadores funcionar. Comecei diversas vezes do zero, seguindo o tutorial do youtube, mas não consegui mapear as classes com anotações customizadas para dentro do container. Algum detalhe ficou para trás. Como última alternativa implementei a funcionalidade usando quase que totalmente a API de reflexão do Java.


TASK 
9
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
10
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


============================================
Elder José Reioli Cirilo
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Implementei a tarefa, armazenando a relação entre atributo anotado e parâmetro na classe ParameterMapperContainer em um método específico chamado "configure()". Já a configuração da instancia de acordo com os parâmetros presentes no comando, implementei na própria classe ParamMapper, no método readParameters.
DIFICULDADES
Não encontrei dificuldades na implementação desta tarefa. Gastei apenas um tempo inicial procurando encontrar o melhor local para implementar os dois diferentes comportamentos, o relacionado a leitura do metadados e o outro relacionado a criação da instancia. Neste ponto, ainda tenho dúvidas se tomei as melhores decisões, como apresentadas na questão anterior.


TASK 
2
IMPLEMENTAÇÃO
Implementei a leitura dos valores em um método, a princípio, genérico, implementado na classe ParamMapper, que veio a substituir o método configure, implementado anteriormente (Tarefa I) na classe ParamMapperContainer. Com isso, a partir de agora, todo o processamento das anotações permaneceram na classe ParamMapper.
DIFICULDADES
Não encontrei dificuldade quanto ao uso da API de Reflexão do Java. Maior desafio desta tarefa foi evoluir o framework para capturar os valores associados ao parâmetros.


TASK 
3
IMPLEMENTAÇÃO
Implementei a solução percorrendo a lista de atributos anotados com @TextValue e, para cada atributos verifiquei se ele ou a classe estou anotados com @Mandatory. Em casos positivos, consulto na lista de parâmetros se o respectiva parâmetro foi fornecido na linha de comando.
DIFICULDADES
Não encontrei dificuldade para implementar esta tarefa.


TASK 
4
IMPLEMENTAÇÃO
Completei a tarefa implementando as regras na própria classe ParamMapper. Inclusive, observei que não deveria ter removido o método "configureMetadata()" da classe ParamMapperContainer. Este método está implementando as regras de verificação de tipo.
DIFICULDADES
Não encontrei dificuldades na implementação desta tarefa no que diz respeito a a API e decisões passada de design.


TASK 
5
IMPLEMENTAÇÃO
Validei as regras das anotações na classe ParamMapperContainer e implementei a validação dos valores passados na linha de comando na classe ParamMapper como um adendo ao processamento da anotação @TextValue
DIFICULDADES
Não encontrei dificuldades na implementação desta tarefa


TASK 
6
IMPLEMENTAÇÃO
Validei as regras na classe ParamMapperContainer e implementei a leitura dos valores da linha de comando na classe ParamMapper como um adento ao comportamento de leitura da anotação @NumericValue
DIFICULDADES
Não encontrei dificuldades na execução da tarefa.


TASK 
7
IMPLEMENTAÇÃO
Implementei a validação da regra de que não pode ocorrer junto com @Mandatory na classe ParamMapperContainer. Na classe ParamMapper, extrai as lógicas de processamento da linha de comando para um método em separado que passou a ser chamado recursivamente para processar as anotações na classe do type do atributo anotado com @CompositeParameter
DIFICULDADES
Não encontrei dificuldade para implementar esta tarefa.


TASK 
8
IMPLEMENTAÇÃO
Basicamente implementei esta tarefa percorrendo todas as anotações presentes na classe, porém observando quais delas estavam anotadas com @ParameterAnnotation. Para cada uma, por reflexão, coletei a instancia da interface ParameterAnnotationProcessor e primeiramente chamei o método readAnnotation. Posteriormente, com base nos valores na linha de comando o método setParameter foi chamado.
 
DIFICULDADES
Não encontrei dificuldade para implementar essa tarefa.


TASK 
9
IMPLEMENTAÇÃO
Implementei a tarefa validando os tipos validos na classe ParamMapperContainer conforme TIP na descrição da tarefa. Na class ParamMapper implementei as regras de associação dos valores como adendos ao processamento da annotation @TextValue e @NumericValue.
DIFICULDADES
Não encontrei dificuldades para implementar esta tarefa. A atividade mais trabalhosa foi a de implementar os validadores para a anotação @NumericValue por conta das diversas opções.


TASK 
10
IMPLEMENTAÇÃO
Implementei a tarefa seguindo o mesmo padrão de implementação das anotações @TextValue e @NumericValue, validando o uso da anotação na classe ParamMapperContainer e a lógica de processamento da linha de comando na classe ParamMapper.
DIFICULDADES
Não encontrei dificuldade para execução dessa tarefa.


============================================
Gustavo Furtado de Oliveira Alves
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Criei um container para os campos anotados com @IsParameterPresent, adicionei a lista desses containers de campos no ParamMapperContainer e alterei o método do ParamMapper para obter o container utilizando o Esfinge Metadata.
Para obtenção dos valores eu iterei nos container de campos e, para cada fieldContainer eu setei no objeto a informação se o parâmetro estava presente. Fiz isso com o BeanUtils.
DIFICULDADES
Ao final, eu tive que validar se a anotação @IsParameterPresent só estava em campos do tipo boolean ou Boolean, não sabia como fazer isso, mas abri a documentação do framework e descobri a anotação @ValidFieldType.
Achei nome desta anotação intuitiva e o exemplo deixou claro que essa anotação resolveria o meu problema. Funcionou de primeira.


TASK 
2
IMPLEMENTAÇÃO
Alterei o FieldContainer que criei na tarefa anterior para verificar se o campo foi anotado com TextValue e para obter o parâmetro "nome" da anotação.
Refatorei a classe para ter legibilidade para estes dois tipos de metadados (@ContainsAnnotation e @AnnotationProperty) não confundir com os metadados criados na task anterior (@IsParameterPresent)
Na ParamMapper eu separei a lógica das duas anotações (@IsParameterPresent e @TextValue em um if-else.
Por fim fiz uma refatoração na classe ParamMapper para melhorar a legibilidade do código.
DIFICULDADES
Em relação ao design eu pensei em criar uma abstração do FieldContainer e no container de classe separar os parâmetros por anotação, mas decidi adicionar mais dois campos no FieldContainer para atender ao requisito da nova Task. Talvez eu faça esta refatoração para melhorar o design nas próximas tasks, mas por enquanto não vi necessidade.


TASK 
3
IMPLEMENTAÇÃO
Essa atividade foi a mais simples. Foi necessário apenas incluir a validação se o campo é obrigatório na parte do código que obtém o "TextValue". Se o o campo estiver anotado com então o valor do campo não pode ser nulo ou vazio.
E para verificar quando a anotação @Mandatory estiver na classe ao invés do atributo, bastou adicionar a anotação @SearchOnEnclosingElements na anotação @Mandatory.
DIFICULDADES
Nenhuma dificuldade. A implementação das tasks anteriores facilitou a implementação desta task.


TASK 
4
IMPLEMENTAÇÃO
A implementação desta task foi parecida com a Task 2. Eu defini os tipos possíveis para a anotação (short, int, long, etc...) Adicionei o @ContainsAnnotation e o @AnnotationProperty para a anotação NumericValue no FieldContainer e no ParamMapper.readParameters eu adicione o preenchimento do campo para este novo tipo. A conversão eu utilizei apenas o Double.parseDouble por ser o tipo de maior capacidade.
DIFICULDADES
Sem dificuldade.


TASK 
5
IMPLEMENTAÇÃO
Adicionei as anotações @MinValue e @MaxValue do esfinge metadata e, após a obtenção do valor do parâmetro, adicionei as validações de min e max e também a validação da expressão regular de ParamFormat.
Inclui no método "readMetadata" a validação de min < max.
E para validar que as novas anotações precisavam anotar apenas campos com a anotação TextValue eu adicione e anotação @NeedsToHave(TextValue.class) do esfinge metadata.
DIFICULDADES
No inicio eu me confundi um pouco sobre como pegaria o valor do parâmetro, havia me esquecido que podia usar a anotação @AnnotationProperty.
Sobre a validação de obrigatoriedade da anotação TextValue eu não sabia qual anotação usar, mas sabia que era possível validar com o framework, então busquei na documentação e encontrei a anotação @NeedsToHave.
Fora isso, não tive mais dificuldades.


TASK 
6
IMPLEMENTAÇÃO
Esta tarefa foi muito parecida com a anterior (5).
Adicionei as novas informações de metadados no fieldContainer.
Anotei as duas novas anotações com @NeedsToHave(NumericValue.class) para restringir o uso da anotação apenas quando a NumericValue for utilizada.
Restringi a anotação @ParameterPrecision com a anotação @ValidFieldType({float.class, Float.class, double.class, Double.class})
E defini o @MinValue do parâmetro decimalPlaces como 0 para não aceitar valor negativo.
A anotação @ParameterRange não teve nada de especial além do @NeedsToHava(NumericValue.class)
Na ParamMapper eu validei se o valor min ou o max foi preenchido no momento da leitura dos metadados e na configuração do valor do campo eu fiz as validações de range e de precisão máxima.
DIFICULDADES
Não encontrei dificuldades.


TASK 
7
IMPLEMENTAÇÃO
Eu implementei usando recursividade tanto na obtenção dos containers das composições, quanto na obtenção/validação dos parâmetros.
Além disso eu adicionei a anotação @Prohibits(Mandatory.class) na @CompositeParameter para não permitir as duas anotações no mesmo campo.
DIFICULDADES
Não consegui obter o tipo do campo usando o esfinge metadata. Procurei na documentação do framework, mas não encontrei a solução.
Optei por obter essa informação via reflection mesmo, assim: readMetadata(paramClass.getDeclaredField(fc.getFieldName()).getType()).
Mas achei que essa informação, embora não seja propriamente relacionada a anotação, é um metadado poderia ser obtido através do framework. O container de tipo tem a @ReflectionReference, mas não encontrei o mesmo para o container do campo.


TASK 
8
IMPLEMENTAÇÃO
Configurei o ParameterAnnotation com @SearchInsideAnnotations e @SearchOnEnclosingElements para que ela fosse encontrada pelo EsfingeMetadata.
Adicionei no ParamMapperContainer um map configurado como @ProcessorPerField(configAnnotation=ParameterAnnotation.class,type=ProcessorType.READER_IS_PROCESSOR)
No método readMetadata eu adicionei a chamada ao readAnnotation obtendo a anotação do campo por reflection. Eu também usei reflection para verifiar se a anotação era anotada com @ParameterAnnotation.
Por fim, no método readParameters eu adicionei a chamada ao setParameter do processor, também utilizando reflection para obter as informações necessárias.
DIFICULDADES
Eu tive dificuldade em obter as anotações do campo. Tentei fazer tudo com o a API do framework, mas não consegui as informações de anotações que eu precisava. Então decidi utilizar reflection e consegui saber se o campo era @Mandatory e também invocar a propriedade "name" para obter o nome do parâmetro que eu deveria obter da linha de comando.


TASK 
9
IMPLEMENTAÇÃO
IMPORTANTE! Antes de executar a Task 9 eu descobri que não tinha executado todos os testes para a Task 8, me desculpe. E vários testes antigos estavam falhando, por causa da alteração da task 8.
Minha tratativa: Antes de começar a Task 9 eu fiz a correção dos testes antigos e essa correção foi rápida (3 min). Eu mensurei o tempo dessa correção (descrita no log Fluorite antes da task 9 que segue por e-mail em paralelo a esse formulário).
Com esta correção peço que ACRESCENTE 3 MINUTOS NO TEMPO QUE ENVIEI PARA A TASK 8.

Descrição da implementação da Task 9
================================
No método readMetadata eu acrescentei uma verificação da classe do Campo, se for List.class, eu obtenho o tipo genérico do campo e verifico se o tipo é String para @TextValue e se é Short, Integer, Float ou Double para @NumericValue.
No método readParameters eu também verifico se é uma List, nesse caso eu faço um split da lista por ";" e aplico as validações (Text ou Numeric) para cada item individualmente e adiciono na propriedade a lista ou o número individual (caso não seja List).
DIFICULDADES
Não tive dificuldades para esta implementação. A dica do documento da Task para obtenção do tipo genérico foi de grande valia.


TASK 
10
IMPLEMENTAÇÃO
Esta implementação foi bem simples por causa do Esfinge Metadata, pois bastou adicionar a anotação @ValidateFieldType na @DateValue para restringir a anotação para o tipo Date. Em seguida adicionei no container a verificação se a anotação está presente no campo com @ContainsAnnotation(DateValue.class) e adicionei os atributos da anotação que eu precisaria utilizando a @AnnotationProperty.
Por fim, bastou alterar o método readParameters do ParamMapper para obter o parâmetro data no formato correto (com uma instancia de SimpleDateFormat) e verificar se a @Mandatory está presente para validar a obrigatoriedade do parâmetro.

DIFICULDADES
Sem dificuldades.


============================================
Julio Cesar P. Santana
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Analisei os requisitos e os testes propostos. Criei atributo do tipo mapa para armazenar o campo, como chave e o valor da anotação como valor.Com base nos parâmetros recebidos, os campos anotados, recebiam true ou false e caso o parâmetro não correspondesse a algum valor de anotação, era ignorado.
DIFICULDADES
a API não expõe de modo facilitado os campos que possuem anotação/ valor. Na biblioteca BeanUtils, o método getProperty não reconheceu o campo booleano, indicando sua inexistência. Optei por utilizar o método setAccessible de objeto Field e obter o valor através do método get.


TASK 
2
IMPLEMENTAÇÃO
Percorri todos os argumentos passados como parâmetro validando seu início com "-". capturei o argumento em uma variável e os valores em outra e no final da leitura, antes de encontrar um novo parametro, recuperei do repositório os campos que foram anotados pelo parametro, identifiquei a anotação e setei o valor correspondente no campo.
DIFICULDADES
Dificuldade de identificar de modo mais simplificado os campos que possuem uma dada anotação.


TASK 
3
IMPLEMENTAÇÃO
Após a aplicação dos valores repassados de acordo com os parametros, realizei um loop pelos atributos da classe verificando se eram mandatórios ou se a própria classe era, após recuperei o valor do campo da instancia da classe e verifiquei se era nulo ou vazio, lançando exceção caso o campo fosse mandatório.
DIFICULDADES
localização dos atributos que possuem restrição, como o de campo mandatório.


TASK 
4
IMPLEMENTAÇÃO
Ao ler os campos para armazenagem no container, verifico se o tipo é diferente de número, se sim lanço a exceção. Antes de gravar os valores de acordo com o parametro, verifico se o valor é numérico e se existem mais de um valor numérico repassado, se sim lanço a exceção. Após verifico se existe algum campo mandatório.
DIFICULDADES
Ter na API algum método que identifique de modo mais simples o tipo, como isTypeNumeric.


TASK 
5
IMPLEMENTAÇÃO
Na leitura da classe identifiquei a existência da anotação TextValue e armazenei o valor do parâmetro. Validei se existia as anotações ParameterFormat e ParameterLength, sem a TextValue. Validei também o intervalo da anotação ParameterLength. 
Durante a atribuição dos valores validei o formato e o tamanho dos valores repassados de acordo com parâmetro.
DIFICULDADES
Uma forma mais prática na API de descobrir se uma anotação pode ou não ser aplicada a um determinado campo ou sua dependência de outra anotação.


TASK 
6
IMPLEMENTAÇÃO
Na leitura da classe, validei o intervalo e durante a leitura verifiquei se o valor estava dentro do intervalo no caso do parâmetro estar associado a anotação ParameterRange e caso não, verifiquei a precisão.
DIFICULDADES
A API não oferecer método direto que permita identificar uma anotação como requisito para outra e a validade para um determinado tipo de campo.


TASK 
7
IMPLEMENTAÇÃO
Na leitura da classe, verifique criei um método que retorna um mapa tendo como chave o campo e valor o parametro. Verifique se a anotação do campo lido era CompositeParameter e fiz um loop recursivo repassando para o método os campos da classe composite. Executei também validações quanto a classe possuir construtor vazio, não ter campo mandatório associado ao campo composite e não ser de tipo abstrato.
Na inclusão verifiquei se o campo armazenado no mapa era da instancia ou da subclasse, caso fosse da subclasse(field composite) instanciei a classe e atribui o valor ao campo dessa classe e depois atribui a instancia da subclasse ao campo composite da classe principal.
DIFICULDADES
A biblioteca BeanUtils no método getProperty apresentou um erro na recuperação do valor do campo, necessitei usar o metodo setAccessible e get do Field, para recuperar o valor.


TASK 
8
IMPLEMENTAÇÃO
Na leitura da classe, armazenei os campos e os parametros das anotações sobre eles. Depois na leitura dos comandos, verifiqueis campos que possuiam o parametro, crei um método que lê o campo e verifica se a anotação de marcação(ParameterAnnotation) está presente,  e caso estivesse, recuperava o valor que era uma classe que implementava a interface ParameterAnnotationProcessor, instanciei e com objeto criado executei o readAnnotation e o setParameter, somente quando havia parametro para leitura, caso não esse método era ignorado. Por último li a instancia da classe de teste em busca de campos mandatórios não preenchidos.
DIFICULDADES
API não fornece um meio facilitador para seleção de agrupamento de anotações correlacionadas.


TASK 
9
IMPLEMENTAÇÃO
Na leitura da classe através de um loop pelos seus campos, executei o método getGenericType do field, obtive um ParameterizedType e através dele identifiquei se o campo era do tipo List, sendo através do método getActualTypeArguments obtive o tipo associado ao List. De posse do tipo, realizei a validação da anotação sobre o campo lançando uma exceção caso o tipo não seja válido.
Na inclusão dos valores, realizo um loop pelos parametros inputados e recupero os campos anotados com ele. Para cada campo, do tipo list, recupero o tipo e valido para determinar se é preciso fazer cast do valor antes de armazena-lo em um List. Após utilizando a biblioteca BeanUtils, realizo a gravação do list no campo da instancia da classe repassa.
DIFICULDADES
Identificação do tipo usado no List generic, não existe um método que facilite essa operação na API.


TASK 
10
IMPLEMENTAÇÃO
Na leitura dos campos da classe, faço um loop por todos os campos e verifico a existência da anotação TextValue e DateValue. Para os campos DateValue, valido o tipo e caso não seja date, lanço uma exceção, do contrário armazeno o campo e o parametro em um mapa e em um segundo mapa o campo e o formato. 
Ao realizar a inserção dos valores, seleciono os campos que foram anotados com determinado parametro, faço um loop pela lista de campos obtidos e para cada campo, obtenho o pattern e o forneço junto com valor da data inputada para o método getDateFormatted, esse devolve um mapa com a data formatada em string e date.
Comparo o valor retornado pelo método getDateFormatted com o valor do input e caso sejam iguais armazeno na instância. 
Depois de buscar todos os parametros inputados, verifico se existe algum campo mandatório não preenchido e caso tenha lanço uma exceção.
DIFICULDADES
.


============================================
Leonardo de Aguiar Pereira
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Criei a anotação IsParameterPresent, depois o container para o tipo FIELDS BooleanPropertyContainer. Associei uma lista destes containers no ParamMapperContainer, que por sua vez foi anotado como um container de TYPE. Na anotação inseri a validação para apenas aceitar os tipos Boolean e boolean. No BooleanPropertyContainer inseri uma propriedade para armazenar o nome do atributo e uma para obter o valor da anotação IsParameterPresent para este atributo. Com isso já seria possível obter uma classe e partir dela obter todos os campos Boolean ou boolean que tivessem a anotação IsParameterPresent, bem com o valor desta anotação. Assim, no código principal do framework, bastou inicializar o container ParamMapperContainer usando o AnnotationReader, e depois fazer um processamento dos seus atributos e, para cada argumento passado pela linha de comando ao executar o framework, verificar se a anotação IsParameterPresent daquele atributo estaria com o valor de acordo com o parametro passado. Inicialmente seto o valor do atributo para false, e caso ocorra de encontrar o parametro eu seto para true.
DIFICULDADES
Tive uma certa dificuldade em saber exatamente onde iria inicializar o AnnotationReader, depois em como eu iria ajustar os valor dos campos, mas lembrei do BeanUtils e aí fluiu. 


TASK 
2
IMPLEMENTAÇÃO
Criada a anotação TextValue e seu container de FIELDS TextValueContainer. Atribuido ao ParamMapperContainer uma lista de TextValueContainers, pode onde o AnnotationReader se encarregará de popular os metadados pertinentes. No processamento dos argumentos, fiz um loop por todos os campos da classe que possuiam a anotação TextValue e verifiquei contra a lista de argumentos passados pela linha de comando. Neste loop, primeiro tratei de identificar a presença de um parametro, e depois de seus valores. Quando encontra-se um valor antes de ter encontrado um parametro, retorna-se o erro de que linhas de comando não podem iniciar com valores. Quando encontra-se um parametro, testa-se para ver se o parametro é relativo ao parametro mapeado no TextValue corrente (no loop), se sim, seguia procurando seus valores. Para cada valor encontrado, vai-se populando o atributo da objeto daquele parametro, caso nenhum valor fosse encontrado, o atributo ficava com valor vazio.
DIFICULDADES
A maior dificuldade foi na lógica de processamento dos argumentos dentro do loop dos atributos anotados com o TextValue.


TASK 
3
IMPLEMENTAÇÃO
Criei a anotação Mandatory. Configurei no ParamMapperContainer sua presença. Configurei também no TextValueContainer sua presença. No processamento dos parâmetros, verifiquei se a classe inteira deve ter atributos mandatórios e setei algumas variáveis de apoio, o mesmo verifiquei para cada atributo sendo lido pelo loop dos atributos anotados com TextValue. Com isso, consegui identificar quando um atributo está presente e se está vazio, para então jogar os erros caso sejam atributos mandatórios.
DIFICULDADES
nan


TASK 
4
IMPLEMENTAÇÃO
Criei a anotação NumericValue e seu container NumericValueContainer. Inseri na ParamMapperContainer uma lista de NumericValues. No processamento, se deu basicamente como no TextValue, aproveitei boa parte do bloco alterando apenas alguns detalhes para se adaptar à realidade dos requisitos em relação à campos numéricos.
DIFICULDADES
Pequena dificuldade em usar algum recurso do java que permitisse descobrir se uma string continha apenas números inteiros ou decimais.


TASK 
5
IMPLEMENTAÇÃO
Criei as anotações ParameterLength e ParameterFormat, fiz as configurações de NeedsToHave em ambas, para que elas sejam diretamente dependentes da anotação TextValue. Na anotação ParameterLength, criei os atributos min e max, e usei as anotações MinValue e MaxValue para limitar o tamanho mínimo e máximo permitido para esses atributos. No container TextValueContainer, inseri atributos que identificam a presença dessas duas novas anotações, bem como o mapeamento dos atributos min, max e expression. Já no código do processamento do framework, na parte de leitura dos metadados, coloquei uma validação para a anotação ParameterLength, para impedir que seja configurado um valor de min (minLength) maior dor que o valor de max (maxLength). E na parte de leitura os parametros passados pela linha de comando, inseri validações para impedir que fossem passados valores maiores ou menores do que os permitidos pelas configurações min e max da anotação ParameterLength, bem como também a validação pela expressão regular configurada na anotação ParameterFormat.
DIFICULDADES
Fiquei na dúvida onde colocaria a validação que verifica se o valor de min é maior do que o valor de max. Resolvi colocar na parte de leitura dos metadados do framework, e depois acreditei que este seria o lugar correto.


TASK 
6
IMPLEMENTAÇÃO
Criei as anotações ParameterRange e ParameterPrecision e configurei para que elas fossem dependentes da anotação NumericValue. Inseri os atributos min e max na anotação ParameterRange e o atributo decimalPlaces na anotação ParameterPrecision. Adicionei a validação MinValue para que o atributo decimalPlaces não pudesse ser negativo. Criei no NumericValueContainer atributos que identificam as anotações ParameterRange e ParameterPrecision, bem como o mapeamento de seus atributos min, max e decimalPlaces. No processamento do framework, adicionei validações no momento da leitura dos metadados para verificar se foram passados os atributos min ou max e se o valor de min seria maior que o valor de max. Na leitura dos parametros vindos da linha de comando, adicionei validações para checar se o numero está dentro do configurado para min e max da anotação ParameterRange e se o número de casas decimais respeita o configurado em decimalPlaces da anotação ParameterPrecision.
DIFICULDADES
Dificuldade em descobrir como validar se uma anotação foi passada sem nenhuma propriedade onde as propriedades da anotação possuem valores padrões. Acabei por utilizar a lógica de que: se os valores de min e max fossem iguais aos valores padrões, é porque não foi passada nenhuma das duas propriedades.


TASK 
7
IMPLEMENTAÇÃO
Criei a anotação CompositeParameter e seu container CompositeParameterContainer. No container ParamMapperContainer, mapeei os campos com a anotação CompositeParameter para uma lista de CompositeParameterContainer. Criei uma outra anotação chamada CompositeField, que recebe uma classe de Annotation como value. Configurei essa anotação CompositeField para que use um Reader personalizado, que criei chamado CompositeParameterProcessor (eu deveria ter criado como CompositeFieldReader o nome, eu ia renomear mas acabei esquecendo). Este reader tem por função ler os detalhes da classe mapeada com CompositeParameter. No container CompositeParameterContainer, inseri um atributo do tipo ParamMapperContainer para receber as configurações lidas pelo CompositeParameterProcessor. No processamento linha de comando, resgato esse atributo e a partir dele crio uma instância do objeto passado na anotação CompositeParameter. Com este objeto criado, submeto ele ao mapeamento do framework, onde o fluxo segue normalmente, populando e validando esse objeto de acordo com seus metadados.
DIFICULDADES
Tive uma grande dificuldade em entender o funcionamento do recurso @AnnotationReadingConfig. Fiz os procedimentos de acordo com o vídeo instrucional deste recurso (em: https://www.youtube.com/watch?v=qMms_3Ke1YM&feature=youtu.be) e por alguma razão a minha classe de processador não executa os métodos initAnnotation nem o read. Precisei pedir ajuda ao Marco Nardes, o qual me explicou meu erro, eu estava criando o @AnnotationReadingConfig no lugar errado, eu precisaria de uma anotação extra, que iria receber um objeto de anotação e nele faria as leituras. Com isso, consegui superar a dificuldade e finalizar a tarefa.


TASK 
8
IMPLEMENTAÇÃO
Criei a anotação ParameterAnnotation, e sabia que ela iria precisar de receber um processador como value, criei então este processador chamado ParameterAnnotationProcessor, que na verdade é uma interface, criei como sugerido no texto da tarefa. O método readAnnotation desta interface recebeu a anotação @ExecuteProcessor. A anotação ParameterAnnotation precisou de uma anotação @SearchInsideAnnotations, para que ela pudesse ser encontrada dentro de outras anotações. Criei o container ParameterAnnotationContainer para receber as anotações ParameterAnnotation. Depois, no container ParamMapperContainer, inseri uma lista de ParameterAnnotationContainer para anotações ParameterAnnotation. No container ParamenterAnnotationContainer, inseri uma lista de processadores, o utilizei a anotação @CustomReader para fazer como que todos os processadores fossem direcionados para este atributo. Com isso, consegui mapear as anotações estendidas do framework (criadas pelos usuários) juntamente com seus respectivos processadores (também criados pelos usuários). Bastou então configurar como o framework iria encontrar e processador corretamente essas anotações e seus processadores. Para isso, no processador de linha de comando, fiz a leitura de todas os container ParamenterAnnotationContainer, e com cada um obtive o respectivo processador da anotação, e com ela cada campo anotado com a aquela anotação. Depois bastou itinerar por cada anotação, obtendo seu valor e comparar com o que estava vindo na linha de comando, pois o valor da anotação seria o parâmetro esperado da linha de comando. Quando encontrado um parametro de acordo, setava seu valor usando o método do processador, que aí ficava por conta da programação do usuário sobre como ele iria popular aquele atributo.
DIFICULDADES
Tive dificuldade em montar a parte de leitura dos processadores, o que tomou a maior parte do tempo do desenvolvimento (cerca de 2 horas). Precisei interromper a tarefa pois havia dado minha hora de sair para trabalhar. Ao voltar do trabalho, 7 horas depois, retomei a tarefa, onde não tive grandes dificuldades para finalizar. Não considero que minha interrupção tenha causado impactos na realização da tarefa.


TASK 
9
IMPLEMENTAÇÃO
Para fazer o reconhecimento de um valor do tipo lista, precisei fazer uma alteração na forma como eu lia as linhas de comando, pois eu fazia uma lógica para identificar os parâmetros e os valores um a um separadamente. Passei a usar a lógica que desenvolvi para a tarefa 8, onde eu reestruturo a linha de comando e percorro sobre ela resgatando os valores completos de cada parâmetro. Com isso, verifiquei se o valor possuía ponto e vírgula (;) que é o indicativo de aquele valor deve ser quebrado e armazenado como lista. Para saber o tipo de lista que era esperado, precisei obter o tipo nos containers tanto da anotação TextValue quanto da NumericValue. Para isso utilizei a técnica do leitor personalizado e criei as anotações TextField e NumericField, bem como seus leitores personalizados TextFieldReader e NumericFieldReader. Dentro deles, usei reflexão para obter o tipo de cada lista e armazenar na propriedade type dos containers TextValueContainer e NumericValueContainer. Com isso foi possível fazer as validações de tipo no momento do processamento da linha de comando, bem como criar as listas de valores de acordo com seus tipos para popular o atributo anotado.
DIFICULDADES
Tive pequenas dificuldades em lidar com os generics, principalmente no momento de instanciar a lista. 


TASK 
10
IMPLEMENTAÇÃO
Criei a anotação DateValue e seu container DateValueContainer. Configurei um atributo no container ParamMapperContainer para receber uma lista de DateValueContainer a partir de campos anotados com @DateValue. No processamento da linha de comando, percorri por todos os containers do tipo DateValueContainer para processar cada anotação DateValue do objeto passado. Precisei utilizar o método antigo de varredura de linha de comando, pois alguns formatos de data incluíam o hífen, utilizado para fazer separação dos comandos da linha. Com o método antigo, a separação é feita por espaços em branco, o que permite resgatar linhas de comando como -DATE dd-mm-yyyy sem se confundir com os hifens do formato. De posse o valor do parâmetro, bastou tentar criar uma instância de SimpleDateFormat com o formato passado na anotação, caso não conseguisse retornaria um erro. Em caso de sucesso, o campo seria populado no atributo.
DIFICULDADES
Nenhuma dificuldade significativa


============================================
Marcelo dos Santos
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Realizei o mapeamento (nome do parâmetro para Field) dos campos com a anotação especificada, verificando o tipo do mesmo (primitivo e wrapper), assim disponibilizando dois métodos para respectivamente: selecionar todos os campos com possibilidade de null (para a inicialização dos valores em false) e todos os campos correspondente ao argumento de parâmetros (para o ajuste em true).
DIFICULDADES
A inicialização para os valores de tipo wrapper, pois ocorre uma redundância de ajuste quando o parâmetro é enviado pelo cliente.


TASK 
2
IMPLEMENTAÇÃO
Primeiramente foi necessário uma refatoração para a estrutura de mapeamento de classe aceitar múltiplos campos para o mesmo parâmetro, seguido da lógica de mapeamento. No processamento dos argumentos houve o acréscimo de um novo mapa (parâmetro por argumento), o que facilitou (como também simplificou) o processamento em si. Na criação do mapa houveram diversas manipulações de Strings para realizar a separação do parâmetro e seu valor, como também a validação dos casos de exceção.
DIFICULDADES
Dois pontos de dificuldades foram a utilização do mesmo parâmetro em dois campos e existir argumentos compostos na linha de comando. Outro ponto é a falta de abstração na anotação, como em caso de interfaces, pois necessito de um novo “if” para o processamento de cada anotação.


TASK 
3
IMPLEMENTAÇÃO
Realizei duas verificações para a anotação Mandatory: quando na classe, uma variável booleana é ajustada; e quando específico no campo, um novo map é utilizado para esse ajuste; ambos disponibilizados por um novo método de busca por parâmetro, quando para a configuração dos argumentos aos campos. No processamento apenas o controle de verificação para testar quando os parâmetros estavam faltantes ou vazios com suas respectivas exceções.
DIFICULDADES
Não encontrei dificuldades quando ao projeto para a tarefa, apenas na implementação por um erro entre escolher a anotação Mandatory em lugar de TextValue (debug), talvez uma possível refatoração na classe de processamento seja viável na próxima tarefa.


TASK 
4
IMPLEMENTAÇÃO
Na classe de mapeamento o procedimento foi exatamente igual ao para a anotação para Textos, ou seja, a verificação dos tipos e seu respectivo mapeamento. Na classe de processamento o processo foi parecido com o tipo Texto, porém foi necessário a realização da conversão entre String para Número, afim de verificar quaisquer problemas no parse.
DIFICULDADES
A API do framework não apresentou dificuldade quanto a inclusão de uma nova anotação, porém ficou visível a necessidade de refatoração para reduzir lógicas parecidas. Na API de reflexão houve uma dúvida quando a verificação da superclasse, no caso, sendo utilizada invertida: alvo por superclasse ao invés de superclasse por alvo, verificado com um pequeno teste.


TASK 
5
IMPLEMENTAÇÃO
Os pontos vistos como requeridos de refatoração na tarefa anterior foram feitos, com a substituição do mapeamento de Map<String, <List <Field>>> para Map<Field, Param>, classe essa responsável por manter todos os dados sobre cada parâmetro – o que reduziu a complexidade para criação do mapeamento e a verbosidade no momento de processamento.
Na classe de mapeamento, foi abstraído cada verificação de anotação com o método process, na qual recebe o field, anotação, o predicado para validação e sua mensagem de erro, com duas versões, sendo: uma para realizar a criação do Param e a outra para consumir um bloco com a recuperação e validação dos atributos da anotação.
O antigo método getFieldName (realizava a comparação das anotações) foi abstraído para o getAttribute, na qual recebe o atributo (name, min, max e expression) a ser executado (pelo invoke) e retorna seu valor, conforme o tipo esperado pelo chamador.
No processamento, a iteração realiza apenas uma vez com a lista de parâmetros e seleciona cada tipo de dado, no TextValue a validação do Length e Format apenas recupera as propriedades de Param e aplica ao argumento da linha de comando.
DIFICULDADES
A API não apresentou problemas com relação as demais tarefas, apenas uma dúvida em relação a validação de uso dos atributos de ParameterLength nos requisitos, solucionada por e-mail (não necessitou a validação, conforme os testes), porém na implementação do mapeamento, o método process poderia ser único para executar o Consumer e no processamento está revelando um padrão, o que poderia necessitar de uma futura refatoração.


TASK 
6
IMPLEMENTAÇÃO
O mapeamento e processamento das anotações foi análogo ao da Task 5 (com a diferença de Texto para Número), com o preenchimento de Param com os valores recuperados e sua comparação com os valores dos argumentos da linha de comando.
DIFICULDADES
Não encontrei problemas com a API, entretanto os métodos execute no mapeamento e readParameters no processamento estão com aspecto de completo.


TASK 
7
IMPLEMENTAÇÃO
No início foi feito uma correção da tarefa 6, pois o cache do ambiente não indicava a falta de valores padrões para o ParameterRange.
Para a tarefa 7, no mapeamento: o método execute foi modificado para comportar chamadas cíclicas com a classe a ser mapeada e um path para o campo base, para isso foi feito uma extração de método antigo para mapParam. Quando anotada por CompositeParameter são realizadas verificações e encaminhada seu tipo novamente ao método execute com o nome do campo como path, senão são encaminhados ao método extraído com a modificação (mapParam). A classe Param agora guarda o path no momento de sua criação. O mapeamento também possui todos os Consumers extraídos para variáveis.
No processamento, foi adicionado o método initProperty com o objeto e caminho do campo. Nesse método são divididas as partes do caminho e iteradas sem utilização da última parte (nome do campo final). A cada iteração há uma construção progressiva do caminho e a recuperação da propriedade do objeto. No caso de nula, pela atual parte do caminho é realizada a busca da classe do campo, seguida pela criação do objeto e configuração da mesma no objeto.
DIFICULDADES
A API não apresentou maiores problemas, porém a classe de processamento apresenta uma maior complexidade em readParameters.


TASK 
8
IMPLEMENTAÇÃO
Na abstração de Param, foi adicionada uma nova variável para a verificação de custom (boolean).
No mapeamento, o campo é iterado por suas anotações, assim quando encontrada uma com a anotação de ParameterAnnotation, obtém-se a classe da propriedade value e cria um novo objeto com o mesmo, após realiza a chamada do método readAnnotation com os elementos presentes (anotação e campo). Por fim cria um novo mapeamento do campo, ajusta a variável custom e adiciona esse objeto com uma propriedade do parâmetro.
No processamento, uma nova verificação para a variável custom do atual parâmetro e as validações quanto a mandatory. Quando ok, recupera o objeto das propriedades e chama o método setParameter com os elementos presentes (objeto e argumento da linha de comando).
DIFICULDADES
Encontrei dificuldades para entender essa nova etapa da API, principalmente quanto a navegabilidade até a classe atribuída ao value de ParameterAnnotation, pois foi uma atividade nova em reflexão, porém com algumas execuções e leituras dos erros no console, foi possível ter essa visão e concluir a tarefa.


TASK 
9
IMPLEMENTAÇÃO
No mapeamento foi adicionado uma nova verificação no predicado do método process para validar as classes de texto e numérica pela obtenção dos tipos genérico de listas. E uma nova propriedade foi adicionada ao parâmetro (Param) com o tipo genérico.
No processamento foi verificado quando com existe a propriedade list e realizado a conversão dos argumentos para uma lista. Quando texto, não precisou de nenhum tratamento. E quando numérico, os valores foram convertidos conforme a classe da propriedade list.
DIFICULDADES
A API não apresentou problemas, pois a obtenção dos tipos genéricos foi dada como dica nos requisitos. Na conversão da lista de String para Number foi um pouco confuso, porém solucionado com a verificação da classe.


TASK 
10
IMPLEMENTAÇÃO
A refatoração prevista nas tarefas anteriores fora aplicada, através do padrão Chain of Responsibility com a abstração dos tipos: ParamHandler para o mapeamento e ArgumentHandler para o processamento, após a conclusão da refatoração, os requisitos da tarefa 10 foi iniciada.
No mapeamento foi criado um novo ParamHandler por ParamHandlerDataValue com a realização das etapas de verificação da anotação, tipo de dado e recuperação do argumento da anotação (format), assim criando uma instância de SimpleDateFormat com o padrão recuperado e adicionando como uma propriedade de Param.
No processamento foi criado um novo ArgumentHandler por ArgumentHandlerDateValue com a realização das etapas de verificação da anotação, argumento, mandatório e a recuperação da propriedade format pela atribuição a um SimpleDateFormat, assim chamando o parse do mesmo com o argumento da linha de comando e atribuindo a propriedade do objeto final.
Para remover o conflito dos caracteres dos parâmetros e datas, o parse da linha de comando foi alterado para pular o primeiro caractere e dividir por espaço-traço ([ ]-), após a verificação das condições iniciais do mesmo.
DIFICULDADES
A refatoração melhorou a API aplicada as tarefas, o que facilitou na inclusão de DateValue. O único problema foi no parse da linha de comando, pois a expressão regular conflitou com o padrão de datas, no caso o traço (-).


============================================
Ricardo Terra
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Implementei usando Container
DIFICULDADES
Tive problema com os testes de unidade. Contatei o Marco e ele me explicou que eu devia usar um Container já existente. Fiz as alterações e funcionou. Além disso, perdi um bom tempo com exceção relativa ao teste "nonBoleanParamMapped", já que a exceção retornada era de tipo diferente, mesmo sendo Runtime.


TASK 
2
IMPLEMENTAÇÃO
Simplesmente adicionei um novo tratamento para quando se tratava de String. Foi fácil, pois toda a estrutura já estava pronta.
DIFICULDADES
Esse foi bem tranquilo, acredito que o primeiro contato (tarefa 1) deu trabalho, mas nesse eu não tive dificuldades.


TASK 
3
IMPLEMENTAÇÃO
Basicamente criei uma nova anotação, no TextValueContainer coloquei um atributo que verifica se é mandatório e depois fiz poucos ajustes no ParamMapper. E também coloquei NeedsToHave e SearchOnEnclosingElements.
DIFICULDADES
Essa foi tranquila.


TASK 
4
IMPLEMENTAÇÃO
Criei uma nova anotação, modifiquei o ParamMapper para mapear essa anotação e fiz a lógica. Pronto!
DIFICULDADES
Uma coisa me chamou a atenção e por isso fiquei 20 minutos a mais nessa tarefa. Quando executo o Teste4 passa com sucesso, mas quando eu executo um suite de testes que criei AllTests, ele dá problema.


TASK 
5
IMPLEMENTAÇÃO
Criei as anotações. Coloquei algumas das restrições no ParamMapper, mas tive que criar um Validation para a questão do Min não poder ser maior que Max.
DIFICULDADES
Fiquei na dúvida no que dava para implementar facilmente e o que tinha que implementar com validator. Na verdade, existe validações a nível de valores dos campos e a nível de valores das anotações, o que me confude bastante.


TASK 
6
IMPLEMENTAÇÃO
Criei as anotações. Fiz uma alteração do validator do min max para ser genérico para string e números. Ajustei o NumericValueContainer. Fiz ajustes do ParamMapper para verificar os valores. E pronto!
DIFICULDADES
Sobre o ParameterRange que deve especificar pelo menos o Min ou o Max, eu não soube como fazer, mas tudo passou nos testes de unidade e optei por avançar para a Tarefa 7.


TASK 
7
IMPLEMENTAÇÃO
Criei a anotação. Coloquei Proihibits para Mandatory. Modifiquei o ParamContainer para criar chamar o map do objeto do tipo Composite quando encontrar um.
DIFICULDADES
Eu travei na hora de implementar o composite. O Marco me ajudou com a dica de que deveria apenas chamar o mapper novamente. Pronto! No entanto, terminei a tarefa com a falha de um teste. Parece um pouco inconsistente os testes validValues e withoutMandatory. A classe CompositeParamClassTask7 tem um @Mandatory em um campo @NumericValue. Isso é confuso para mim. E além do mais não está claro se não pode ter @Mandatory no atributo que tem @CompositeParameter ou se não pode ter nenhum @Mandatory dentro de uma classe que é @Composite. Confundi um pouco!


TASK 
8
IMPLEMENTAÇÃO
Tive sérios problemas. O Marco me ajudou. A ideia do processor não é fácil. Com um empurrão, consegui implementar. Tive que criar um novo Container, configurar o Processor, alterar a classe ParamMapper para incluir esse tipo e fazer a lógica de atribuição.
DIFICULDADES
Problema com a documentação. Entendi pouco o que era para fazer também. Se não fosse com a ajuda do Marco, não sei se conseguiria.


TASK 
9
IMPLEMENTAÇÃO
Fiz um AnnotationValidator. Deu errado e peguei um caminho errado usando processor. Depois vi meu erro e fiz um AnnotationValidator para String. Depois fiz o mesmo genérico para TextValue e NumericValue. Depois ajustei o TextValueContainer para pegar o field e ver o tipo. Depois fiz a lógica no ParamMapper e garanti que testes de unidade anteriores estava passando propriamente.
DIFICULDADES
nan


TASK 
10
IMPLEMENTAÇÃO
Essa foi tranquila. Criei um Container para DateValue. Criei um método do ParamMapperContainer que retorna todos os campos com essa anotação. Fiz os tratamentos em ParamMapper e pronto. Tudo funcionando. Inclusive executei todos os 10 testes de unidades e todos com sucesso.
DIFICULDADES
nan


