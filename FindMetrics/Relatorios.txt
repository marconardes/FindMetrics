Alfredo M. Funada
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
2
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
3
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
4
IMPLEMENTAÇÃO
nan
DIFICULDADES
Enfrentei alguns problemas por conhecer pouco sobre o java, mas também não tinha idéia do que precisava estudar antes, então comecei a tarefa e quando foi aparecendo as dificuldades fui buscando as informações.


TASK 
5
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
6
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
7
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
8
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
9
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
10
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


============================================
Ana Flavia Lemos
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Criei a classe FieldMapperContainer para armazenar as informações sobre a anotação isParameterPresent e a classe ClassMapperContainer para capturar todos os campos anotados com @IsParameterPresent. Na classe ParameterMapper com base nos metadados coletados eu validei o comando de acordo com as regras. 
DIFICULDADES
Não encontrei dificuldades na implementação desta tarefa.


TASK 
2
IMPLEMENTAÇÃO
Criei uma nova classe FieldTextValueMapperContainer responsável por manter os metadados da anotação TextValue e completei a leitura dos valores da linha de comando na classe ParameterMapper.
DIFICULDADES
Não encontrei dificuldades para implementar esta tarefa.


TASK 
3
IMPLEMENTAÇÃO
Coletei as informações da anotação @Mandatory na classe FieldTextValueContainer e completei a classe ParamMapper para validar a existência ou não dos parâmetros obrigatório.
DIFICULDADES
Não encontrei dificuldades para implementar essa tarefa.


TASK 
4
IMPLEMENTAÇÃO
Criei a classe FieldNumericValue para manter os metadados relacionados a anotação @NumericValue. Completei o processamento das anotações na classe ParamMapper com as regras relacionadas ao uso da anotação @NumericValue.
DIFICULDADES
Não encontrei dificuldade para implementar esta tarefa.


============================================
Daniel Mário de Lima
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Os metadados são salvos em Container.parameters (HashMap) e verificados um a um pela existência do parâmetro no vetor da linha de comando.
DIFICULDADES
Me confundi brevemente entre BeanUtils e a API de reflexão padrão.


TASK 
2
IMPLEMENTAÇÃO
Separei a verificação da anotação em duas classes auxiliares, uma para Boolean e outra para String, e coloquei a leitura da linha de comando em um objeto com um StringBuffer opcional.
DIFICULDADES
Minha principal dificuldade foi decidir quais objetos seriam responsáveis pela leitura e armazenamento de cada informação necessária para ler os valores. No fim, deixei o mapa de campos e parâmetros no ParamMapperContainer e o parsing da linha de comando no ParamMapper.


TASK 
3
IMPLEMENTAÇÃO
Generalizei as classes de processamento de parâmetros para qualquer tipo de anotação, criando uma lista de comandos para processar cada anotação de cada atributo da classe, e então adicionei um comando para processar a anotação Mandatory.
DIFICULDADES
Nessa tarefa o processo fluiu de forma mais direta, mas ainda é percebido algum atrito em decidir mudanças arquiteturais.


TASK 
4
IMPLEMENTAÇÃO
Criei novo processador de Anotações para o valor Numérico com a lógica necessária e adicionei como campo aceito em Mandatory e ParamMapperContainer.
DIFICULDADES
Tive que usar a API de reflexão diretamente para conseguir atribuir null como valor default, pois o comportamento padrão do BeanUtils converte nulls automaticamente para zero no caso de valores numéricos.


TASK 
5
IMPLEMENTAÇÃO
Segui os mesmos passos anteriores, criei novos AnnotationProcessors chamados de LengthParameter e FormatParameter que carregam e processam os dados, fazendo as verificações e lançando as exceções solicitadas.
DIFICULDADES
Essa tarefa foi bem direta, não tive muito trabalho.


TASK 
6
IMPLEMENTAÇÃO
Adicionei os processadores referentes às anotações, e aproveitei para refatorar um método da interface dos refatoradores, já que era uma funcionalidade repetida em dois métodos separados. 
DIFICULDADES
Nenhuma, tudo correu bem.


TASK 
7
IMPLEMENTAÇÃO
Utilizei a própria API do ParamMapper para criar mapeadores de objetos recursivamente ao encontrar CompositeParameters.
DIFICULDADES
Esta tarefa foi surpreendentemente simples, já que os outros requisitos da tarefa não haviam sido implementados explicitamente.


TASK 
8
IMPLEMENTAÇÃO
Fiz uma grande refatoração para adaptar a estrutura de AnnotationProcessor à API solicitada, mudando assinaturas de métodos e modelo de dados do ParamMapperContainer.
DIFICULDADES
Como foi uma refatoração grande (cirurgia com rifle), foi bem mais trabalhoso que as outras tarefas, onde eu tinha que parar constantemente para relembrar a arquitetura e seguir um checklist das mudanças necessárias.


TASK 
9
IMPLEMENTAÇÃO
Verificando o tipo e subtipo (genérico) do field em StringParameter e NumberParameter (AnnotationProcessors), instanciando os objetos List antes de atribuí-los ao objeto.
DIFICULDADES
Me confundi um pouco com a API de reflexão em genéricos, mas nada muito grave.


TASK 
10
IMPLEMENTAÇÃO
Criei a AnnotationProcessor para Dates, checando o tipo do campo e validade do formato, retornando exceções nos casos inválidos.
DIFICULDADES
A refatoração da tarefa 8 foi bem trabalhosa, mas fez as tarefas 9 e 10 serem muito mais simples de se implementar. Se não me engano, a tarefa 10 foi a mais rápida dentre todas.


============================================
David Buzatto
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Implementei utilizando a IDE NetBeans, visto que o Eclipse estava dando muitos erros. Acredito que na cópia dos arquivos prontos do NetBeans para o Eclipse eu talvez tenhe entendido o motivo dos erros do Eclipse. A próxima tarefa tentarei fazer no Eclipse.
DIFICULDADES
Gostei da API Esfinge, mas ainda não consigo decidir se é melhor usá-la ou ir direto com a API de reflexão do Java. Por enquanto, continuaria com a API do Java, visto que parece ser mais direta ao ponto, ao invés de ter que ficar criando classes de container com n anotações.


TASK 
2
IMPLEMENTAÇÃO
Implementei no Eclipse, foi tudo bem. Realizei os testes um por um até tudo estar ok, além de usar diversos printlns para verificar alguns valores. Fiz os testes inicial e da tarefa 1, que ficaram quebrados, ajustei todo o código até tudo passar. Está tudo ok.
DIFICULDADES
nan


TASK 
3
IMPLEMENTAÇÃO
Fiz a implementação usando tanto a API do Java quanto a Esfinge.
DIFICULDADES
nan


TASK 
4
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
5
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
6
IMPLEMENTAÇÃO
De forma parecida com a tarefa das anotações para texto. Parei um pouco para dar uma refatorada no código, criando uma classe para abrigar diversos métodos estáticos para o algoritmo de mapeamento.
DIFICULDADES
nan


TASK 
7
IMPLEMENTAÇÃO
Adaptação do algoritmo para ser recursivo possibilitando o tratamento de @CompositeParameter
DIFICULDADES
nan


TASK 
8
IMPLEMENTAÇÃO
Utilizei a API de reflexão do Java.
DIFICULDADES
Foram feitas diversas tentativas usando o Esfinge Metadata, mas infelizmente não consegui fazer o mecanismo de processadores funcionar. Comecei diversas vezes do zero, seguindo o tutorial do youtube, mas não consegui mapear as classes com anotações customizadas para dentro do container. Algum detalhe ficou para trás. Como última alternativa implementei a funcionalidade usando quase que totalmente a API de reflexão do Java.


TASK 
9
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


TASK 
10
IMPLEMENTAÇÃO
nan
DIFICULDADES
nan


============================================
Denny Paulista Azevedo Filho
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Depois de analisar os testes solicitados, e com base nos exercícios anteriores, criei a anotação, conforme solicitado, e implementei, inicialmente, a busca pelo nome (parâmetro da anotação). Na sequencia implementei uma busca do nome da anotação, nos parâmetros passados no acionamento do método, um Arrays de Strings, que invocaria um método de atribuição (invocando os métodos setters correspondentes), para as situações previstas na tarefa. Implementei um método que invocava o Setter do Field correspondente ao nome passado, com o valor booleano informado. O último ajuste foi a troca da exceção padrão, pela criada na tarefa e utilizada nos testes. 
DIFICULDADES
Minha maior dificuldade ainda é no retorno do uso da Linguagem Java, nos dois últimos dois anos apenas trabalhei com C# e Python. O uso de reflexões e anotações é novo para mim, logo, ainda tenho uma curva de aprendizado a cumprir, isso só causa uma lentidão no processo de solução, mas não uma barreira.


TASK 
2
IMPLEMENTAÇÃO
Aproveitei o código da tarefa 1, ajustando par os requisitos da nova tarefa. Foi necessário um ajuste no código da tarefa 1, para manter os dois testes funcionais. Acredito que ainda caiba alguma refatoração, mas de imediato a solução adotada atende as exigências do teste.
DIFICULDADES
nan


TASK 
3
IMPLEMENTAÇÃO
Aproveitamento do código básico da task2, fazendo busca da anotação, incluindo a busca na classe. 
DIFICULDADES
nan


TASK 
4
IMPLEMENTAÇÃO
Aproveitei os códigos anteriores das task 2 e 3, para localização das annotations, extração de nomes, métodos, parâmetros e valores. Fiz um ajuste na verificação da annotation Mandatory, para comportar as novas funcionalidades. E montei uma verificação para a nova annotation (Numericvalue) levando em consideração a diversidade de tipos, necessitando conversões, e o modo diferente para o acionamento dos métodos (até aqui o nome indicava o método). Não foi talves a solução mais elegante, mas está funcional....talvez uma melhor aplicação de técnicas mais avançadas de OO permita um reajuste do código.
DIFICULDADES
nan


TASK 
5
IMPLEMENTAÇÃO
Com base na tarefa anterior, foi efetuado os ajustes para determinar as anotações específicas, modificação do método para a anotação Mandatory.
DIFICULDADES
nan


TASK 
6
IMPLEMENTAÇÃO
Modificação e adaptação da atividade 5.
DIFICULDADES
nan


TASK 
6
IMPLEMENTAÇÃO
Modificação e adaptação da atividade 5.
DIFICULDADES
nan


============================================
Denny Paulita Azevedo Filho
Usando API de Reflexão do Java
TASK 
7
IMPLEMENTAÇÃO
Criei nova Instância de ParamMapper, para receber a classe do elemento composto. E com isso criei uma "recursividade" da classe. Verificando todas as possibilidades de annotations já verificados.
DIFICULDADES
Como ocorreu mudanças nas chamadas dos métodos Setters, foi necessário ajustes no  código já testado.


============================================
Elder José Reioli Cirilo
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Implementei a tarefa, armazenando a relação entre atributo anotado e parâmetro na classe ParameterMapperContainer em um método específico chamado "configure()". Já a configuração da instancia de acordo com os parâmetros presentes no comando, implementei na própria classe ParamMapper, no método readParameters.
DIFICULDADES
Não encontrei dificuldades na implementação desta tarefa. Gastei apenas um tempo inicial procurando encontrar o melhor local para implementar os dois diferentes comportamentos, o relacionado a leitura do metadados e o outro relacionado a criação da instancia. Neste ponto, ainda tenho dúvidas se tomei as melhores decisões, como apresentadas na questão anterior.


TASK 
2
IMPLEMENTAÇÃO
Implementei a leitura dos valores em um método, a princípio, genérico, implementado na classe ParamMapper, que veio a substituir o método configure, implementado anteriormente (Tarefa I) na classe ParamMapperContainer. Com isso, a partir de agora, todo o processamento das anotações permaneceram na classe ParamMapper.
DIFICULDADES
Não encontrei dificuldade quanto ao uso da API de Reflexão do Java. Maior desafio desta tarefa foi evoluir o framework para capturar os valores associados ao parâmetros.


TASK 
3
IMPLEMENTAÇÃO
Implementei a solução percorrendo a lista de atributos anotados com @TextValue e, para cada atributos verifiquei se ele ou a classe estou anotados com @Mandatory. Em casos positivos, consulto na lista de parâmetros se o respectiva parâmetro foi fornecido na linha de comando.
DIFICULDADES
Não encontrei dificuldade para implementar esta tarefa.


TASK 
4
IMPLEMENTAÇÃO
Completei a tarefa implementando as regras na própria classe ParamMapper. Inclusive, observei que não deveria ter removido o método "configureMetadata()" da classe ParamMapperContainer. Este método está implementando as regras de verificação de tipo.
DIFICULDADES
Não encontrei dificuldades na implementação desta tarefa no que diz respeito a a API e decisões passada de design.


TASK 
5
IMPLEMENTAÇÃO
Validei as regras das anotações na classe ParamMapperContainer e implementei a validação dos valores passados na linha de comando na classe ParamMapper como um adendo ao processamento da anotação @TextValue
DIFICULDADES
Não encontrei dificuldades na implementação desta tarefa


TASK 
6
IMPLEMENTAÇÃO
Validei as regras na classe ParamMapperContainer e implementei a leitura dos valores da linha de comando na classe ParamMapper como um adento ao comportamento de leitura da anotação @NumericValue
DIFICULDADES
Não encontrei dificuldades na execução da tarefa.


TASK 
6
IMPLEMENTAÇÃO
Infelizmente, eu esqueci de copiar os casos de teste referentes a tarefa 6 e após uma implementação parcial me enganei com a completude do código e imaginei que minha versão havia passado em todos os testes. Executando então os casos de testes da Tarefa 6 eu percebi que algumas validações referentes ao uso da anotação não estavam completas. Com isso, implementei elas na classe ParamMapperContainer. Refiz o commit do código da tarefa com a label "Terefa #6 - Complemento". O tempo neste formulário se refere a soma do tempo gasto anteriormente, na execução da tarefa, e anotado no formulário submetido anteriormente, mais o tempo gasto para implementar a validações finais.
DIFICULDADES
Não encontrei dificuldade para implementar o complemento.


TASK 
7
IMPLEMENTAÇÃO
Implementei a validação da regra de que não pode ocorrer junto com @Mandatory na classe ParamMapperContainer. Na classe ParamMapper, extrai as lógicas de processamento da linha de comando para um método em separado que passou a ser chamado recursivamente para processar as anotações na classe do type do atributo anotado com @CompositeParameter
DIFICULDADES
Não encontrei dificuldade para implementar esta tarefa.


TASK 
8
IMPLEMENTAÇÃO
Basicamente implementei esta tarefa percorrendo todas as anotações presentes na classe, porém observando quais delas estavam anotadas com @ParameterAnnotation. Para cada uma, por reflexão, coletei a instancia da interface ParameterAnnotationProcessor e primeiramente chamei o método readAnnotation. Posteriormente, com base nos valores na linha de comando o método setParameter foi chamado.
 
DIFICULDADES
Não encontrei dificuldade para implementar essa tarefa.


TASK 
9
IMPLEMENTAÇÃO
Implementei a tarefa validando os tipos validos na classe ParamMapperContainer conforme TIP na descrição da tarefa. Na class ParamMapper implementei as regras de associação dos valores como adendos ao processamento da annotation @TextValue e @NumericValue.
DIFICULDADES
Não encontrei dificuldades para implementar esta tarefa. A atividade mais trabalhosa foi a de implementar os validadores para a anotação @NumericValue por conta das diversas opções.


TASK 
10
IMPLEMENTAÇÃO
Implementei a tarefa seguindo o mesmo padrão de implementação das anotações @TextValue e @NumericValue, validando o uso da anotação na classe ParamMapperContainer e a lógica de processamento da linha de comando na classe ParamMapper.
DIFICULDADES
Não encontrei dificuldade para execução dessa tarefa.


============================================
Gustavo Furtado de Oliveira Alves
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Criei um container para os campos anotados com @IsParameterPresent, adicionei a lista desses containers de campos no ParamMapperContainer e alterei o método do ParamMapper para obter o container utilizando o Esfinge Metadata.
Para obtenção dos valores eu iterei nos container de campos e, para cada fieldContainer eu setei no objeto a informação se o parâmetro estava presente. Fiz isso com o BeanUtils.
DIFICULDADES
Ao final, eu tive que validar se a anotação @IsParameterPresent só estava em campos do tipo boolean ou Boolean, não sabia como fazer isso, mas abri a documentação do framework e descobri a anotação @ValidFieldType.
Achei nome desta anotação intuitiva e o exemplo deixou claro que essa anotação resolveria o meu problema. Funcionou de primeira.


TASK 
2
IMPLEMENTAÇÃO
Alterei o FieldContainer que criei na tarefa anterior para verificar se o campo foi anotado com TextValue e para obter o parâmetro "nome" da anotação.
Refatorei a classe para ter legibilidade para estes dois tipos de metadados (@ContainsAnnotation e @AnnotationProperty) não confundir com os metadados criados na task anterior (@IsParameterPresent)
Na ParamMapper eu separei a lógica das duas anotações (@IsParameterPresent e @TextValue em um if-else.
Por fim fiz uma refatoração na classe ParamMapper para melhorar a legibilidade do código.
DIFICULDADES
Em relação ao design eu pensei em criar uma abstração do FieldContainer e no container de classe separar os parâmetros por anotação, mas decidi adicionar mais dois campos no FieldContainer para atender ao requisito da nova Task. Talvez eu faça esta refatoração para melhorar o design nas próximas tasks, mas por enquanto não vi necessidade.


TASK 
3
IMPLEMENTAÇÃO
Essa atividade foi a mais simples. Foi necessário apenas incluir a validação se o campo é obrigatório na parte do código que obtém o "TextValue". Se o o campo estiver anotado com então o valor do campo não pode ser nulo ou vazio.
E para verificar quando a anotação @Mandatory estiver na classe ao invés do atributo, bastou adicionar a anotação @SearchOnEnclosingElements na anotação @Mandatory.
DIFICULDADES
Nenhuma dificuldade. A implementação das tasks anteriores facilitou a implementação desta task.


TASK 
4
IMPLEMENTAÇÃO
A implementação desta task foi parecida com a Task 2. Eu defini os tipos possíveis para a anotação (short, int, long, etc...) Adicionei o @ContainsAnnotation e o @AnnotationProperty para a anotação NumericValue no FieldContainer e no ParamMapper.readParameters eu adicione o preenchimento do campo para este novo tipo. A conversão eu utilizei apenas o Double.parseDouble por ser o tipo de maior capacidade.
DIFICULDADES
Sem dificuldade.


TASK 
5
IMPLEMENTAÇÃO
Adicionei as anotações @MinValue e @MaxValue do esfinge metadata e, após a obtenção do valor do parâmetro, adicionei as validações de min e max e também a validação da expressão regular de ParamFormat.
Inclui no método "readMetadata" a validação de min < max.
E para validar que as novas anotações precisavam anotar apenas campos com a anotação TextValue eu adicione e anotação @NeedsToHave(TextValue.class) do esfinge metadata.
DIFICULDADES
No inicio eu me confundi um pouco sobre como pegaria o valor do parâmetro, havia me esquecido que podia usar a anotação @AnnotationProperty.
Sobre a validação de obrigatoriedade da anotação TextValue eu não sabia qual anotação usar, mas sabia que era possível validar com o framework, então busquei na documentação e encontrei a anotação @NeedsToHave.
Fora isso, não tive mais dificuldades.


TASK 
6
IMPLEMENTAÇÃO
Esta tarefa foi muito parecida com a anterior (5).
Adicionei as novas informações de metadados no fieldContainer.
Anotei as duas novas anotações com @NeedsToHave(NumericValue.class) para restringir o uso da anotação apenas quando a NumericValue for utilizada.
Restringi a anotação @ParameterPrecision com a anotação @ValidFieldType({float.class, Float.class, double.class, Double.class})
E defini o @MinValue do parâmetro decimalPlaces como 0 para não aceitar valor negativo.
A anotação @ParameterRange não teve nada de especial além do @NeedsToHava(NumericValue.class)
Na ParamMapper eu validei se o valor min ou o max foi preenchido no momento da leitura dos metadados e na configuração do valor do campo eu fiz as validações de range e de precisão máxima.
DIFICULDADES
Não encontrei dificuldades.


TASK 
7
IMPLEMENTAÇÃO
Eu implementei usando recursividade tanto na obtenção dos containers das composições, quanto na obtenção/validação dos parâmetros.
Além disso eu adicionei a anotação @Prohibits(Mandatory.class) na @CompositeParameter para não permitir as duas anotações no mesmo campo.
DIFICULDADES
Não consegui obter o tipo do campo usando o esfinge metadata. Procurei na documentação do framework, mas não encontrei a solução.
Optei por obter essa informação via reflection mesmo, assim: readMetadata(paramClass.getDeclaredField(fc.getFieldName()).getType()).
Mas achei que essa informação, embora não seja propriamente relacionada a anotação, é um metadado poderia ser obtido através do framework. O container de tipo tem a @ReflectionReference, mas não encontrei o mesmo para o container do campo.


TASK 
8
IMPLEMENTAÇÃO
Configurei o ParameterAnnotation com @SearchInsideAnnotations e @SearchOnEnclosingElements para que ela fosse encontrada pelo EsfingeMetadata.
Adicionei no ParamMapperContainer um map configurado como @ProcessorPerField(configAnnotation=ParameterAnnotation.class,type=ProcessorType.READER_IS_PROCESSOR)
No método readMetadata eu adicionei a chamada ao readAnnotation obtendo a anotação do campo por reflection. Eu também usei reflection para verifiar se a anotação era anotada com @ParameterAnnotation.
Por fim, no método readParameters eu adicionei a chamada ao setParameter do processor, também utilizando reflection para obter as informações necessárias.
DIFICULDADES
Eu tive dificuldade em obter as anotações do campo. Tentei fazer tudo com o a API do framework, mas não consegui as informações de anotações que eu precisava. Então decidi utilizar reflection e consegui saber se o campo era @Mandatory e também invocar a propriedade "name" para obter o nome do parâmetro que eu deveria obter da linha de comando.


TASK 
9
IMPLEMENTAÇÃO
IMPORTANTE! Antes de executar a Task 9 eu descobri que não tinha executado todos os testes para a Task 8, me desculpe. E vários testes antigos estavam falhando, por causa da alteração da task 8.
Minha tratativa: Antes de começar a Task 9 eu fiz a correção dos testes antigos e essa correção foi rápida (3 min). Eu mensurei o tempo dessa correção (descrita no log Fluorite antes da task 9 que segue por e-mail em paralelo a esse formulário).
Com esta correção peço que ACRESCENTE 3 MINUTOS NO TEMPO QUE ENVIEI PARA A TASK 8.

Descrição da implementação da Task 9
================================
No método readMetadata eu acrescentei uma verificação da classe do Campo, se for List.class, eu obtenho o tipo genérico do campo e verifico se o tipo é String para @TextValue e se é Short, Integer, Float ou Double para @NumericValue.
No método readParameters eu também verifico se é uma List, nesse caso eu faço um split da lista por ";" e aplico as validações (Text ou Numeric) para cada item individualmente e adiciono na propriedade a lista ou o número individual (caso não seja List).
DIFICULDADES
Não tive dificuldades para esta implementação. A dica do documento da Task para obtenção do tipo genérico foi de grande valia.


TASK 
10
IMPLEMENTAÇÃO
Esta implementação foi bem simples por causa do Esfinge Metadata, pois bastou adicionar a anotação @ValidateFieldType na @DateValue para restringir a anotação para o tipo Date. Em seguida adicionei no container a verificação se a anotação está presente no campo com @ContainsAnnotation(DateValue.class) e adicionei os atributos da anotação que eu precisaria utilizando a @AnnotationProperty.
Por fim, bastou alterar o método readParameters do ParamMapper para obter o parâmetro data no formato correto (com uma instancia de SimpleDateFormat) e verificar se a @Mandatory está presente para validar a obrigatoriedade do parâmetro.

DIFICULDADES
Sem dificuldades.


============================================
Jonathan Camilo de Lima
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Li a tarefa e fiz algumas anotações sobre o que era necessário para concluí-la. Depois de entender o problema eu fui ver como o esfinge metadata poderia me ajudar. Aproveitei a ideia do ClassContainer e FieldContainer das vídeo-aulas e comecei implementar o ParamMapper.
DIFICULDADES
Talvez o parser dos args pode ficar um pouco trabalhoso mais pra frente. Se pudesse usar uma API que já faz isso.


TASK 
2
IMPLEMENTAÇÃO
Fui rodando os testes e ajustando o ParamMapper até passar todos os testes.
DIFICULDADES
Essa já foi um pouco mais trabalhoso pra validar todas as regras.


TASK 
3
IMPLEMENTAÇÃO
Verifiquei se a anotação Mandatory estava presente no campo ou na classe. Se sim, e o campo estivesse vazio eu lançava a exceção ParameterReadingException.
DIFICULDADES
Só uma pequena dificuldade na hora de entender que eu tinha que verificar se a anotação estava presente na classe ou na variável de classe.


============================================
Julio C. P. Santana
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Analisei os requisitos e os testes propostos. Criei atributo do tipo mapa para armazenar o campo, como chave e o valor da anotação como valor.Com base nos parâmetros recebidos, os campos anotados, recebiam true ou false e caso o parâmetro não correspondesse a algum valor de anotação, era ignorado.
DIFICULDADES
a API não expõe de modo facilitado os campos que possuem anotação/ valor. Na biblioteca BeanUtils, o método getProperty não reconheceu o campo booleano, indicando sua inexistência. Optei por utilizar o método setAccessible de objeto Field e obter o valor através do método get.


TASK 
2
IMPLEMENTAÇÃO
Percorri todos os argumentos passados como parâmetro validando seu início com "-". capturei o argumento em uma variável e os valores em outra e no final da leitura, antes de encontrar um novo parametro, recuperei do repositório os campos que foram anotados pelo parametro, identifiquei a anotação e setei o valor correspondente no campo.
DIFICULDADES
Dificuldade de identificar de modo mais simplificado os campos que possuem uma dada anotação.


TASK 
3
IMPLEMENTAÇÃO
Após a aplicação dos valores repassados de acordo com os parametros, realizei um loop pelos atributos da classe verificando se eram mandatórios ou se a própria classe era, após recuperei o valor do campo da instancia da classe e verifiquei se era nulo ou vazio, lançando exceção caso o campo fosse mandatório.
DIFICULDADES
localização dos atributos que possuem restrição, como o de campo mandatório.


TASK 
4
IMPLEMENTAÇÃO
Ao ler os campos para armazenagem no container, verifico se o tipo é diferente de número, se sim lanço a exceção. Antes de gravar os valores de acordo com o parametro, verifico se o valor é numérico e se existem mais de um valor numérico repassado, se sim lanço a exceção. Após verifico se existe algum campo mandatório.
DIFICULDADES
Ter na API algum método que identifique de modo mais simples o tipo, como isTypeNumeric.


TASK 
5
IMPLEMENTAÇÃO
Na leitura da classe identifiquei a existência da anotação TextValue e armazenei o valor do parâmetro. Validei se existia as anotações ParameterFormat e ParameterLength, sem a TextValue. Validei também o intervalo da anotação ParameterLength. 
Durante a atribuição dos valores validei o formato e o tamanho dos valores repassados de acordo com parâmetro.
DIFICULDADES
Uma forma mais prática na API de descobrir se uma anotação pode ou não ser aplicada a um determinado campo ou sua dependência de outra anotação.


TASK 
6
IMPLEMENTAÇÃO
Na leitura da classe, validei o intervalo e durante a leitura verifiquei se o valor estava dentro do intervalo no caso do parâmetro estar associado a anotação ParameterRange e caso não, verifiquei a precisão.
DIFICULDADES
A API não oferecer método direto que permita identificar uma anotação como requisito para outra e a validade para um determinado tipo de campo.


TASK 
7
IMPLEMENTAÇÃO
Na leitura da classe, verifique criei um método que retorna um mapa tendo como chave o campo e valor o parametro. Verifique se a anotação do campo lido era CompositeParameter e fiz um loop recursivo repassando para o método os campos da classe composite. Executei também validações quanto a classe possuir construtor vazio, não ter campo mandatório associado ao campo composite e não ser de tipo abstrato.
Na inclusão verifiquei se o campo armazenado no mapa era da instancia ou da subclasse, caso fosse da subclasse(field composite) instanciei a classe e atribui o valor ao campo dessa classe e depois atribui a instancia da subclasse ao campo composite da classe principal.
DIFICULDADES
A biblioteca BeanUtils no método getProperty apresentou um erro na recuperação do valor do campo, necessitei usar o metodo setAccessible e get do Field, para recuperar o valor.


TASK 
8
IMPLEMENTAÇÃO
Na leitura da classe, armazenei os campos e os parametros das anotações sobre eles. Depois na leitura dos comandos, verifiqueis campos que possuiam o parametro, crei um método que lê o campo e verifica se a anotação de marcação(ParameterAnnotation) está presente,  e caso estivesse, recuperava o valor que era uma classe que implementava a interface ParameterAnnotationProcessor, instanciei e com objeto criado executei o readAnnotation e o setParameter, somente quando havia parametro para leitura, caso não esse método era ignorado. Por último li a instancia da classe de teste em busca de campos mandatórios não preenchidos.
DIFICULDADES
API não fornece um meio facilitador para seleção de agrupamento de anotações correlacionadas.


TASK 
9
IMPLEMENTAÇÃO
Na leitura da classe através de um loop pelos seus campos, executei o método getGenericType do field, obtive um ParameterizedType e através dele identifiquei se o campo era do tipo List, sendo através do método getActualTypeArguments obtive o tipo associado ao List. De posse do tipo, realizei a validação da anotação sobre o campo lançando uma exceção caso o tipo não seja válido.

Na inclusão dos valores, realizo um loop pelos parametros inputados e recupero os campos anotados com ele. Para cada campo, do tipo list, recupero o tipo e valido para determinar se é preciso fazer cast do valor antes de armazena-lo em um List. Após utilizando a biblioteca BeanUtils, realizo a gravação do list no campo da instancia da classe repassa.
DIFICULDADES
Identificação do tipo usado no List generic, não existe um método que facilite essa operação na API.


TASK 
10
IMPLEMENTAÇÃO
Na leitura dos campos da classe, faço um loop por todos os campos e verifico a existência da anotação TextValue e DateValue. Para os campos DateValue, valido o tipo e caso não seja date, lanço uma exceção, do contrário armazeno o campo e o parametro em um mapa e em um segundo mapa o campo e o formato. 
Ao realizar a inserção dos valores, seleciono os campos que foram anotados com determinado parametro, faço um loop pela lista de campos obtidos e para cada campo, obtenho o pattern e o forneço junto com valor da data inputada para o método getDateFormatted, esse devolve um mapa com a data formatada em string e date.
Comparo o valor retornado pelo método getDateFormatted com o valor do input e caso sejam iguais armazeno na instância. 
Depois de buscar todos os parametros inputados, verifico se existe algum campo mandatório não preenchido e caso tenha lanço uma exceção.
DIFICULDADES
.


============================================
Katia Cristina Lage dos Santos
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Inicialmente fiz uma análise do framework proposto e fiquei um tempo entendendo como iria fazer a tarefa com base no que foi dado. Quando iniciei a implementação, inicialmente foi criada a anotação IsParameterPresent. Posteriormente foi criado o método responsável pela captura dos metadados da classe enviada como parâmetro na classe com.pmapper.ParamMapper. Por fim foram feitas duas alterações na classe com.pmapper.ParamMapperContainer: a primeira foi a inclusão da chamada ao método que realiza o mapeamento dos metadados na classe com.pmapper.ParamMapper e posteriormente foi realizada a implementação do método que avalia os parâmetros passados e define a chamada ou não dos métodos do tipo set para os campos do tipo boolean ou java.lang.Boolean como verdadeiro. Apesar do valor default dos campos do tipo lógico em Java serem iniciados como falso, coloquei explicitamente a atribuição false para todos os campos lógicos inicialmente já que isso foi descrito explicitamente na tarefa.
DIFICULDADES
A principal dificuldade foi com relação ao tratamento diferenciado do tipo de retorno primitivo boolean e o tipo de retorno da classe Boolean. Posteriormente, ainda tive que fazer um reparo no código para tratar o caso de exceção que é levantada quando a anotação é utilizada incorretamente em algum campo de tipo diferente de um valor lógico (último caso de teste)


TASK 
2
IMPLEMENTAÇÃO
Acompanhando o raciocínio da tarefa anterior, inicialmente fou criada a anotação TextValue. Em seguida, foi criado o método responsável por coletar os metadados da classe com os parâmetros na classe ParamMapperContainer e que trata em específico de atributos do tipo String. Foi feito o mapeamento dos atributos do tipo String e se há anotações do tipo @TextValue em cada um deles. Posteriormente, foi feita a chamada do referido método na classe ParamMapper. Como o código estava ficando muito extenso, inicialmente foi feita uma modularização do método readParameters, implementado na Tarefa 1, onde foram extraídas todas as instruções anteriormente inseridas para um método readParameterBoolean. A chamada desse método foi incluída no readParameter. Usando a mesma lógica do readParameterBoolean foi criado um método para ler os parâmetros relativos aos atributos anotado como TextValue. O diferencial nesse método foi a criação de uma  rotina específica para lidar com os argumentos recebidos já que nesta tarefa poderia ter um número indefinido de argumentos referentes a valores de um determinado argumento.
DIFICULDADES
A principal dificuldade nessa tarefa foi criar um método para lidar com os argumentos passados na linha de comando. Como não havia um número específico de tokens a cada novo teste o método mapearArgumentosValores teve que ser modificado para contemplar outros casos. 


TASK 
3
IMPLEMENTAÇÃO
Inicialmente foi criada a anotação @Mandatory. Em seguinda, na classe ParamMapperContainer foi criado o método verifyMandatoryAnnotationInClass que verifica se essa anotação foi realizada no nível da classe. Se isso for identificado, o valor default do atributo de classe defaultMandory é verdadeiro, indicando que todos os atributos do tipo String deverão obrigatoriamente informados como argumento. Em seguida, foi realizada uma alteração no método createMetadataMapTextValue que define os metadados de atributos com a notação @TextValue. Nele foi incluída a verificação da existência da anotação @Mandatory a nível de campo. Dependendo da presença ou não da anotação era definida a obrigatoriedade ou não do argumento na linha de comando. Por fim, na classe ParamMapper foi criado um método que avalia os arugumentos passados e verifica se eles atendem às anotações @TextValue  & @@Mandatory, lançando exceção se isso não for atendido.
DIFICULDADES
A única dificuldade foi na implementação do método que avalia a linha de comando. Ele que demandou mais tempo.


============================================
Leonardo de Aguiar Pereira
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Criei a anotação IsParameterPresent, depois o container para o tipo FIELDS BooleanPropertyContainer. Associei uma lista destes containers no ParamMapperContainer, que por sua vez foi anotado como um container de TYPE. Na anotação inseri a validação para apenas aceitar os tipos Boolean e boolean. No BooleanPropertyContainer inseri uma propriedade para armazenar o nome do atributo e uma para obter o valor da anotação IsParameterPresent para este atributo. Com isso já seria possível obter uma classe e partir dela obter todos os campos Boolean ou boolean que tivessem a anotação IsParameterPresent, bem com o valor desta anotação. Assim, no código principal do framework, bastou inicializar o container ParamMapperContainer usando o AnnotationReader, e depois fazer um processamento dos seus atributos e, para cada argumento passado pela linha de comando ao executar o framework, verificar se a anotação IsParameterPresent daquele atributo estaria com o valor de acordo com o parametro passado. Inicialmente seto o valor do atributo para false, e caso ocorra de encontrar o parametro eu seto para true.
DIFICULDADES
Tive uma certa dificuldade em saber exatamente onde iria inicializar o AnnotationReader, depois em como eu iria ajustar os valor dos campos, mas lembrei do BeanUtils e aí fluiu. 


TASK 
2
IMPLEMENTAÇÃO
Criada a anotação TextValue e seu container de FIELDS TextValueContainer. Atribuido ao ParamMapperContainer uma lista de TextValueContainers, pode onde o AnnotationReader se encarregará de popular os metadados pertinentes. No processamento dos argumentos, fiz um loop por todos os campos da classe que possuiam a anotação TextValue e verifiquei contra a lista de argumentos passados pela linha de comando. Neste loop, primeiro tratei de identificar a presença de um parametro, e depois de seus valores. Quando encontra-se um valor antes de ter encontrado um parametro, retorna-se o erro de que linhas de comando não podem iniciar com valores. Quando encontra-se um parametro, testa-se para ver se o parametro é relativo ao parametro mapeado no TextValue corrente (no loop), se sim, seguia procurando seus valores. Para cada valor encontrado, vai-se populando o atributo da objeto daquele parametro, caso nenhum valor fosse encontrado, o atributo ficava com valor vazio.
DIFICULDADES
A maior dificuldade foi na lógica de processamento dos argumentos dentro do loop dos atributos anotados com o TextValue.


TASK 
3
IMPLEMENTAÇÃO
Criei a anotação Mandatory. Configurei no ParamMapperContainer sua presença. Configurei também no TextValueContainer sua presença. No processamento dos parâmetros, verifiquei se a classe inteira deve ter atributos mandatórios e setei algumas variáveis de apoio, o mesmo verifiquei para cada atributo sendo lido pelo loop dos atributos anotados com TextValue. Com isso, consegui identificar quando um atributo está presente e se está vazio, para então jogar os erros caso sejam atributos mandatórios.
DIFICULDADES
nan


TASK 
4
IMPLEMENTAÇÃO
Criei a anotação NumericValue e seu container NumericValueContainer. Inseri na ParamMapperContainer uma lista de NumericValues. No processamento, se deu basicamente como no TextValue, aproveitei boa parte do bloco alterando apenas alguns detalhes para se adaptar à realidade dos requisitos em relação à campos numéricos.
DIFICULDADES
Pequena dificuldade em usar algum recurso do java que permitisse descobrir se uma string continha apenas números inteiros ou decimais.


TASK 
5
IMPLEMENTAÇÃO
Criei as anotações ParameterLength e ParameterFormat, fiz as configurações de NeedsToHave em ambas, para que elas sejam diretamente dependentes da anotação TextValue. Na anotação ParameterLength, criei os atributos min e max, e usei as anotações MinValue e MaxValue para limitar o tamanho mínimo e máximo permitido para esses atributos. No container TextValueContainer, inseri atributos que identificam a presença dessas duas novas anotações, bem como o mapeamento dos atributos min, max e expression. Já no código do processamento do framework, na parte de leitura dos metadados, coloquei uma validação para a anotação ParameterLength, para impedir que seja configurado um valor de min (minLength) maior dor que o valor de max (maxLength). E na parte de leitura os parametros passados pela linha de comando, inseri validações para impedir que fossem passados valores maiores ou menores do que os permitidos pelas configurações min e max da anotação ParameterLength, bem como também a validação pela expressão regular configurada na anotação ParameterFormat.
DIFICULDADES
Fiquei na dúvida onde colocaria a validação que verifica se o valor de min é maior do que o valor de max. Resolvi colocar na parte de leitura dos metadados do framework, e depois acreditei que este seria o lugar correto.


TASK 
6
IMPLEMENTAÇÃO
Criei as anotações ParameterRange e ParameterPrecision e configurei para que elas fossem dependentes da anotação NumericValue. Inseri os atributos min e max na anotação ParameterRange e o atributo decimalPlaces na anotação ParameterPrecision. Adicionei a validação MinValue para que o atributo decimalPlaces não pudesse ser negativo. Criei no NumericValueContainer atributos que identificam as anotações ParameterRange e ParameterPrecision, bem como o mapeamento de seus atributos min, max e decimalPlaces. No processamento do framework, adicionei validações no momento da leitura dos metadados para verificar se foram passados os atributos min ou max e se o valor de min seria maior que o valor de max. Na leitura dos parametros vindos da linha de comando, adicionei validações para checar se o numero está dentro do configurado para min e max da anotação ParameterRange e se o número de casas decimais respeita o configurado em decimalPlaces da anotação ParameterPrecision.
DIFICULDADES
Dificuldade em descobrir como validar se uma anotação foi passada sem nenhuma propriedade onde as propriedades da anotação possuem valores padrões. Acabei por utilizar a lógica de que: se os valores de min e max fossem iguais aos valores padrões, é porque não foi passada nenhuma das duas propriedades.


TASK 
7
IMPLEMENTAÇÃO
Criei a anotação CompositeParameter e seu container CompositeParameterContainer. No container ParamMapperContainer, mapeei os campos com a anotação CompositeParameter para uma lista de CompositeParameterContainer. Criei uma outra anotação chamada CompositeField, que recebe uma classe de Annotation como value. Configurei essa anotação CompositeField para que use um Reader personalizado, que criei chamado CompositeParameterProcessor (eu deveria ter criado como CompositeFieldReader o nome, eu ia renomear mas acabei esquecendo). Este reader tem por função ler os detalhes da classe mapeada com CompositeParameter. No container CompositeParameterContainer, inseri um atributo do tipo ParamMapperContainer para receber as configurações lidas pelo CompositeParameterProcessor. No processamento linha de comando, resgato esse atributo e a partir dele crio uma instância do objeto passado na anotação CompositeParameter. Com este objeto criado, submeto ele ao mapeamento do framework, onde o fluxo segue normalmente, populando e validando esse objeto de acordo com seus metadados.
DIFICULDADES
Tive uma grande dificuldade em entender o funcionamento do recurso @AnnotationReadingConfig. Fiz os procedimentos de acordo com o vídeo instrucional deste recurso (em: https://www.youtube.com/watch?v=qMms_3Ke1YM&feature=youtu.be) e por alguma razão a minha classe de processador não executa os métodos initAnnotation nem o read. Precisei pedir ajuda ao Marco Nardes, o qual me explicou meu erro, eu estava criando o @AnnotationReadingConfig no lugar errado, eu precisaria de uma anotação extra, que iria receber um objeto de anotação e nele faria as leituras. Com isso, consegui superar a dificuldade e finalizar a tarefa.


TASK 
8
IMPLEMENTAÇÃO
Criei a anotação ParameterAnnotation, e sabia que ela iria precisar de receber um processador como value, criei então este processador chamado ParameterAnnotationProcessor, que na verdade é uma interface, criei como sugerido no texto da tarefa. O método readAnnotation desta interface recebeu a anotação @ExecuteProcessor. A anotação ParameterAnnotation precisou de uma anotação @SearchInsideAnnotations, para que ela pudesse ser encontrada dentro de outras anotações. Criei o container ParameterAnnotationContainer para receber as anotações ParameterAnnotation. Depois, no container ParamMapperContainer, inseri uma lista de ParameterAnnotationContainer para anotações ParameterAnnotation. No container ParamenterAnnotationContainer, inseri uma lista de processadores, o utilizei a anotação @CustomReader para fazer como que todos os processadores fossem direcionados para este atributo. Com isso, consegui mapear as anotações estendidas do framework (criadas pelos usuários) juntamente com seus respectivos processadores (também criados pelos usuários). Bastou então configurar como o framework iria encontrar e processador corretamente essas anotações e seus processadores. Para isso, no processador de linha de comando, fiz a leitura de todas os container ParamenterAnnotationContainer, e com cada um obtive o respectivo processador da anotação, e com ela cada campo anotado com a aquela anotação. Depois bastou itinerar por cada anotação, obtendo seu valor e comparar com o que estava vindo na linha de comando, pois o valor da anotação seria o parâmetro esperado da linha de comando. Quando encontrado um parametro de acordo, setava seu valor usando o método do processador, que aí ficava por conta da programação do usuário sobre como ele iria popular aquele atributo.
DIFICULDADES
Tive dificuldade em montar a parte de leitura dos processadores, o que tomou a maior parte do tempo do desenvolvimento (cerca de 2 horas). Precisei interromper a tarefa pois havia dado minha hora de sair para trabalhar. Ao voltar do trabalho, 7 horas depois, retomei a tarefa, onde não tive grandes dificuldades para finalizar. Não considero que minha interrupção tenha causado impactos na realização da tarefa.


TASK 
9
IMPLEMENTAÇÃO
Para fazer o reconhecimento de um valor do tipo lista, precisei fazer uma alteração na forma como eu lia as linhas de comando, pois eu fazia uma lógica para identificar os parâmetros e os valores um a um separadamente. Passei a usar a lógica que desenvolvi para a tarefa 8, onde eu reestruturo a linha de comando e percorro sobre ela resgatando os valores completos de cada parâmetro. Com isso, verifiquei se o valor possuía ponto e vírgula (;) que é o indicativo de aquele valor deve ser quebrado e armazenado como lista. Para saber o tipo de lista que era esperado, precisei obter o tipo nos containers tanto da anotação TextValue quanto da NumericValue. Para isso utilizei a técnica do leitor personalizado e criei as anotações TextField e NumericField, bem como seus leitores personalizados TextFieldReader e NumericFieldReader. Dentro deles, usei reflexão para obter o tipo de cada lista e armazenar na propriedade type dos containers TextValueContainer e NumericValueContainer. Com isso foi possível fazer as validações de tipo no momento do processamento da linha de comando, bem como criar as listas de valores de acordo com seus tipos para popular o atributo anotado.
DIFICULDADES
Tive pequenas dificuldades em lidar com os generics, principalmente no momento de instanciar a lista. 


TASK 
10
IMPLEMENTAÇÃO
Criei a anotação DateValue e seu container DateValueContainer. Configurei um atributo no container ParamMapperContainer para receber uma lista de DateValueContainer a partir de campos anotados com @DateValue. No processamento da linha de comando, percorri por todos os containers do tipo DateValueContainer para processar cada anotação DateValue do objeto passado. Precisei utilizar o método antigo de varredura de linha de comando, pois alguns formatos de data incluíam o hífen, utilizado para fazer separação dos comandos da linha. Com o método antigo, a separação é feita por espaços em branco, o que permite resgatar linhas de comando como -DATE dd-mm-yyyy sem se confundir com os hifens do formato. De posse o valor do parâmetro, bastou tentar criar uma instância de SimpleDateFormat com o formato passado na anotação, caso não conseguisse retornaria um erro. Em caso de sucesso, o campo seria populado no atributo.
DIFICULDADES
Nenhuma dificuldade significativa


============================================
Luiz Wagner Tavares Nascimento
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Criei o container para leitura dos parâmetros da classe pelo Esfinge Metadata, container para armazenar o valor das anotações e utilizei API Reflection para setar o valor dos parâmetros encontrados nos argumentos na nova instância da classe de teste.
DIFICULDADES
Dificuldade de entender como utilizar o Esfinge Metadata, mesmo seguindo o tutorial na documentação.


TASK 
2
IMPLEMENTAÇÃO
Criei a anotação @TextValue, seu respectivo FieldContainer para leitura no ParamContainer pelo EsfigeMetadata e refatorei o método readParameters da classe ParamMapper a fim de extrair o texto dos parâmetros passados nos argumentos. Foi criado também um método privado na classe ParamMapper para validação dos argumentos segundo os requisitos.
DIFICULDADES
Dificuldade não houve dessa vez, pois foi necessário apenas repetir a leitura da anotação já criada.


TASK 
3
IMPLEMENTAÇÃO
Foi criada a anotação @Mandatory e um método privado na classe ParamMapper para checar os parâmetros obrigatórios. Feita a leitura das anotações utilizando a funcionalidade do Esfinge Metadata AnnotationFinder.findAnnotation e uma lógica de comparação da existência da anotação e a leitura dos parâmetros passados na linha de comando.
DIFICULDADES
Não foi difícil incrementar a funcionalidade de parâmetro mandatório, apesar de não ter ficado confuso na documentação qual anotação utilizar, se era a @SearchInsideAnnotations ou @SearchOnEnclosingElements. Após a aplicação no caso de teste, percebi que era a @SearchOnEnclosingElements.


TASK 
4
IMPLEMENTAÇÃO
Inicialmente foi criado o container para a anotação numérica e o novo método de leitura dos parâmetros numéricos, conforme as tarefas anteriores. Porém, como o método ficou grande e repetitivo pela quantidade de parâmetros numéricos possíveis, foi feita uma refatoração para retirar a repetição de código e para contornar um comportamento adverso do Esfinge Metadata.
DIFICULDADES
A dificuldade foi contornar o fato de que os testes estavam passando isoladamente de cada tarefa, porém quando executados todos em conjunto (ou por meio do mvn test), ocorria erro por conta do container possuir anotações das classes dos testes anteriores. Dessa forma, foi necessário refatorar o código para contornar esse comportamento não esperado, ou pelo menos não conhecido por mim até então.


TASK 
5
IMPLEMENTAÇÃO
Foi criados os containers para ParameterLength e ParameterFormat e criados métodos de validação dentro da lógica de leitura de TextValue, caso existam as novas anotações, bem como um método de validação caso uma das novas anotações esteja configurada sem haver @TextValue presente.
DIFICULDADES
A lógica implementada aparentemente estava toda correta, porém ao executar os testes do JUnit apareciam erros aleatórios em diferentes métodos de teste. Foi observado comportamento adverso devido à configuração do Container de Anotações, no método AnnotatioReader.readAnnotationsTo. Bastou a atualização para versão 1.5.5 do Esfinge Metadata para que os testes passassem na lógica implementada.


TASK 
6
IMPLEMENTAÇÃO
Foram criadas as anotações referentes ao @ParameterRange e @ParameterPrecision, seus respectivos FieldContainers e os métodos de validação, tanto de existência das anotações na configuração da classe, como também as validações funcionais referente ao próprio Range e Precision.
DIFICULDADES
nan


TASK 
7
IMPLEMENTAÇÃO
Foi criado o container para a nova anotação @Composite e o método para validação e seu processamento. A partir daí foram checadas as condições de configuração da classe (não abstrata e contendo construtor vazio), criada uma nova instancia do ParamMapper e delegada para ela validar todo o seu conteúdo, como se fosse uma classe primária.
DIFICULDADES
nan


TASK 
8
IMPLEMENTAÇÃO
Foi criada o container de field relacionado à nova anotação customizada - @ParameterAnnotation, esta por sua vez foi relacionada a um Processor do tipo IS_PROCESSOR do framework Metadata. No método Processor.readAnnotation foi adicionada a anotação @ExecuteProcessor, e então no método de validação do mapper os parâmetros são lidos e setados no método Processor.seParameter conforme os requisitos.
DIFICULDADES
Houve uma grande dificuldade em compreender na documentação do framework qual Processor deveria ser utilizado, os exemplos não ficaram tão claros para mim sobre quais configurações deveriam ser feitas nas novas anotações e no uso do @CustomReader. Cheguei a colocar todos os CustomReaders e ProcessorPerFields que haviam disponíveis, mesmo assim não estava conseguindo achar a propriedade "name" da anotação customizada com a nova anotação @ParameterAnnotation, não sei se no framework Metadata isso seria possível. A solução foi acabar modificando a interface do Processor adicionando um método getNameInAnnotation() e então as classes concretas passaram a possuir um campo String nameInAnnotation que seria populado no momento da inicialização do processor no método readAnnotation, que era o local onde encontrei a anotação customizada disponível para obter esse parâmetro que seria lido posteriormente durante o método de validação do mapper.


TASK 
9
IMPLEMENTAÇÃO
Foram alterados apenas os validadores de @TextValue e @NumericValue, passando a considerar os novos requisitos, ou seja, ao pegar o valor passado no argumento, foi a lista foi separada utilizando arg.split[";"], verificado o tipo genérico da lista conforme a dica do requisito (String, Integer ou Double) e então setado com o método correspondente.
DIFICULDADES
nan


TASK 
10
IMPLEMENTAÇÃO
Foi necessário apenas criar o container para leitura do parâmetro Date, no método de validação a classe SimpleDateFormat é instanciada com o formato definido na anotação e então foi o método parse, que nos casos inválidos já lança uma ParseException, sendo então transformada para a exceção de domínio ParameterReadingException.
DIFICULDADES
nan


============================================
Marcelo dos Santos
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Realizei o mapeamento (nome do parâmetro para Field) dos campos com a anotação especificada, verificando o tipo do mesmo (primitivo e wrapper), assim disponibilizando dois métodos para respectivamente: selecionar todos os campos com possibilidade de null (para a inicialização dos valores em false) e todos os campos correspondente ao argumento de parâmetros (para o ajuste em true).
DIFICULDADES
A inicialização para os valores de tipo wrapper, pois ocorre uma redundância de ajuste quando o parâmetro é enviado pelo cliente.


TASK 
2
IMPLEMENTAÇÃO
Primeiramente foi necessário uma refatoração para a estrutura de mapeamento de classe aceitar múltiplos campos para o mesmo parâmetro, seguido da lógica de mapeamento. No processamento dos argumentos houve o acréscimo de um novo mapa (parâmetro por argumento), o que facilitou (como também simplificou) o processamento em si. Na criação do mapa houveram diversas manipulações de Strings para realizar a separação do parâmetro e seu valor, como também a validação dos casos de exceção.
DIFICULDADES
Dois pontos de dificuldades foram a utilização do mesmo parâmetro em dois campos e existir argumentos compostos na linha de comando. Outro ponto é a falta de abstração na anotação, como em caso de interfaces, pois necessito de um novo “if” para o processamento de cada anotação.


TASK 
3
IMPLEMENTAÇÃO
Realizei duas verificações para a anotação Mandatory: quando na classe, uma variável booleana é ajustada; e quando específico no campo, um novo map é utilizado para esse ajuste; ambos disponibilizados por um novo método de busca por parâmetro, quando para a configuração dos argumentos aos campos. No processamento apenas o controle de verificação para testar quando os parâmetros estavam faltantes ou vazios com suas respectivas exceções.
DIFICULDADES
Não encontrei dificuldades quando ao projeto para a tarefa, apenas na implementação por um erro entre escolher a anotação Mandatory em lugar de TextValue (debug), talvez uma possível refatoração na classe de processamento seja viável na próxima tarefa.


TASK 
4
IMPLEMENTAÇÃO
Na classe de mapeamento o procedimento foi exatamente igual ao para a anotação para Textos, ou seja, a verificação dos tipos e seu respectivo mapeamento. Na classe de processamento o processo foi parecido com o tipo Texto, porém foi necessário a realização da conversão entre String para Número, afim de verificar quaisquer problemas no parse.
DIFICULDADES
A API do framework não apresentou dificuldade quanto a inclusão de uma nova anotação, porém ficou visível a necessidade de refatoração para reduzir lógicas parecidas. Na API de reflexão houve uma dúvida quando a verificação da superclasse, no caso, sendo utilizada invertida: alvo por superclasse ao invés de superclasse por alvo, verificado com um pequeno teste.


TASK 
5
IMPLEMENTAÇÃO
Os pontos vistos como requeridos de refatoração na tarefa anterior foram feitos, com a substituição do mapeamento de Map<String, <List <Field>>> para Map<Field, Param>, classe essa responsável por manter todos os dados sobre cada parâmetro – o que reduziu a complexidade para criação do mapeamento e a verbosidade no momento de processamento.
Na classe de mapeamento, foi abstraído cada verificação de anotação com o método process, na qual recebe o field, anotação, o predicado para validação e sua mensagem de erro, com duas versões, sendo: uma para realizar a criação do Param e a outra para consumir um bloco com a recuperação e validação dos atributos da anotação.
O antigo método getFieldName (realizava a comparação das anotações) foi abstraído para o getAttribute, na qual recebe o atributo (name, min, max e expression) a ser executado (pelo invoke) e retorna seu valor, conforme o tipo esperado pelo chamador.
No processamento, a iteração realiza apenas uma vez com a lista de parâmetros e seleciona cada tipo de dado, no TextValue a validação do Length e Format apenas recupera as propriedades de Param e aplica ao argumento da linha de comando.
DIFICULDADES
A API não apresentou problemas com relação as demais tarefas, apenas uma dúvida em relação a validação de uso dos atributos de ParameterLength nos requisitos, solucionada por e-mail (não necessitou a validação, conforme os testes), porém na implementação do mapeamento, o método process poderia ser único para executar o Consumer e no processamento está revelando um padrão, o que poderia necessitar de uma futura refatoração.


TASK 
6
IMPLEMENTAÇÃO
O mapeamento e processamento das anotações foi análogo ao da Task 5 (com a diferença de Texto para Número), com o preenchimento de Param com os valores recuperados e sua comparação com os valores dos argumentos da linha de comando.
DIFICULDADES
Não encontrei problemas com a API, entretanto os métodos execute no mapeamento e readParameters no processamento estão com aspecto de completo.


TASK 
7
IMPLEMENTAÇÃO
No início foi feito uma correção da tarefa 6, pois o cache do ambiente não indicava a falta de valores padrões para o ParameterRange.
Para a tarefa 7, no mapeamento: o método execute foi modificado para comportar chamadas cíclicas com a classe a ser mapeada e um path para o campo base, para isso foi feito uma extração de método antigo para mapParam. Quando anotada por CompositeParameter são realizadas verificações e encaminhada seu tipo novamente ao método execute com o nome do campo como path, senão são encaminhados ao método extraído com a modificação (mapParam). A classe Param agora guarda o path no momento de sua criação. O mapeamento também possui todos os Consumers extraídos para variáveis.
No processamento, foi adicionado o método initProperty com o objeto e caminho do campo. Nesse método são divididas as partes do caminho e iteradas sem utilização da última parte (nome do campo final). A cada iteração há uma construção progressiva do caminho e a recuperação da propriedade do objeto. No caso de nula, pela atual parte do caminho é realizada a busca da classe do campo, seguida pela criação do objeto e configuração da mesma no objeto.
DIFICULDADES
A API não apresentou maiores problemas, porém a classe de processamento apresenta uma maior complexidade em readParameters.


TASK 
8
IMPLEMENTAÇÃO
Na abstração de Param, foi adicionada uma nova variável para a verificação de custom (boolean).
No mapeamento, o campo é iterado por suas anotações, assim quando encontrada uma com a anotação de ParameterAnnotation, obtém-se a classe da propriedade value e cria um novo objeto com o mesmo, após realiza a chamada do método readAnnotation com os elementos presentes (anotação e campo). Por fim cria um novo mapeamento do campo, ajusta a variável custom e adiciona esse objeto com uma propriedade do parâmetro.
No processamento, uma nova verificação para a variável custom do atual parâmetro e as validações quanto a mandatory. Quando ok, recupera o objeto das propriedades e chama o método setParameter com os elementos presentes (objeto e argumento da linha de comando).
DIFICULDADES
Encontrei dificuldades para entender essa nova etapa da API, principalmente quanto a navegabilidade até a classe atribuída ao value de ParameterAnnotation, pois foi uma atividade nova em reflexão, porém com algumas execuções e leituras dos erros no console, foi possível ter essa visão e concluir a tarefa.


TASK 
9
IMPLEMENTAÇÃO
No mapeamento foi adicionado uma nova verificação no predicado do método process para validar as classes de texto e numérica pela obtenção dos tipos genérico de listas. E uma nova propriedade foi adicionada ao parâmetro (Param) com o tipo genérico.
No processamento foi verificado quando com existe a propriedade list e realizado a conversão dos argumentos para uma lista. Quando texto, não precisou de nenhum tratamento. E quando numérico, os valores foram convertidos conforme a classe da propriedade list.
DIFICULDADES
A API não apresentou problemas, pois a obtenção dos tipos genéricos foi dada como dica nos requisitos. Na conversão da lista de String para Number foi um pouco confuso, porém solucionado com a verificação da classe.


TASK 
10
IMPLEMENTAÇÃO
A refatoração prevista nas tarefas anteriores fora aplicada, através do padrão Chain of Responsibility com a abstração dos tipos: ParamHandler para o mapeamento e ArgumentHandler para o processamento, após a conclusão da refatoração, os requisitos da tarefa 10 foi iniciada.
No mapeamento foi criado um novo ParamHandler por ParamHandlerDataValue com a realização das etapas de verificação da anotação, tipo de dado e recuperação do argumento da anotação (format), assim criando uma instância de SimpleDateFormat com o padrão recuperado e adicionando como uma propriedade de Param.
No processamento foi criado um novo ArgumentHandler por ArgumentHandlerDateValue com a realização das etapas de verificação da anotação, argumento, mandatório e a recuperação da propriedade format pela atribuição a um SimpleDateFormat, assim chamando o parse do mesmo com o argumento da linha de comando e atribuindo a propriedade do objeto final.
Para remover o conflito dos caracteres dos parâmetros e datas, o parse da linha de comando foi alterado para pular o primeiro caractere e dividir por espaço-traço ([ ]-), após a verificação das condições iniciais do mesmo.
DIFICULDADES
A refatoração melhorou a API aplicada as tarefas, o que facilitou na inclusão de DateValue. O único problema foi no parse da linha de comando, pois a expressão regular conflitou com o padrão de datas, no caso o traço (-).


============================================
Marco Augusto Ribeiro Nardes
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Foi implementado utilizando as anotações básicas do esfinge metadata.
DIFICULDADES
Nenhuma no momento.


============================================
Marilene Esquiavoni
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Fiz um estudo dos testes a serem aplicados. Elaborei uma lógica para a solução do problema. Iniciei resolvendo como aplicar os valores, conforme solicitado na tarefa. Para isso, programei uma anotação, que possuía um nome como parâmetro, e criei uma função que buscava este nome (com base nos exercícios anteriormente efetuados). Com o nome localizado, procurava no array fornecido como parâmetro. Montei duas opções, nome nos parâmetros, ou não, para atribuir os valores, true ou false, conforme solicitado no exercício. Para isso criei uma nova função (novamente, baseado nos exercícios anteriores), que atribui o valor (treu ou false) ao nome informado, disparando um a exceção, caso isso não fosse possível. Com isso passei 5 dos 6 testes. Para o último teste só foi necessário alterar a exceção disparada.
DIFICULDADES
Minha maior dificuldade é a linguagem. Aprendi o Java na faculdade, e mesmo assim, só OOP básica. Consigo entender toda a lógica necessária, mas demoro para ajustar ao Java. Há alguns anos só tenho utilizado C# e mais recentemente Phyton (mas não com OOP). Também é novo para mim a reflexão e anotação.


TASK 
2
IMPLEMENTAÇÃO
utilizei como base a tarefa anterior com pequenos ajustes
DIFICULDADES
nan


TASK 
3
IMPLEMENTAÇÃO
Utilizei a solução para a tarefa 2 como base. Ajustei o código para procurar a anotação Mandatory, para a classe, e para o campo. Aproveitei parte do código da tarefa 2, visto o Mandatory estar atrelado ao TextValue. 
DIFICULDADES
nan


TASK 
4
IMPLEMENTAÇÃO
Ajustes no código anteriormente utilizado (Task 3) com uma verificação dos tipos de dados (nome do parametro informado), pra conversão e acionamento do método correto.
DIFICULDADES
nan


TASK 
5
IMPLEMENTAÇÃO
Modificações da atividade 4, com ajustes para comportar as novas solicitações de anotações, principalmente no método de verificação da anotação Mandatory.
DIFICULDADES
nan


TASK 
6
IMPLEMENTAÇÃO
Modificação e adaptação da atividade 5
DIFICULDADES
nan


TASK 
7
IMPLEMENTAÇÃO
Criação de objeto da classe ParamMapper para receber o field do tipo (Classe) Composite, permitindo o verificação de seus elementos.
DIFICULDADES
Mudanças nos métodos Setters, nome e tipos, fizeram que fosse necessário reescrever códigos já testados


============================================
Matheus Monteiro Mariano
Usando API de Reflexão do Java
TASK 
1
IMPLEMENTAÇÃO
Editei o método public <E> E map(String[] args, Class<E> paramClass) da classe ParamMapper, adicionando duas comparações principais: 1) se a anotação @IsParameterPresent está presente no método; e se estiver, 2) se o tipo do campo é boleano (boolean ou Boolean). Caso seja verdade nas duas condicionais, insere o valor 'false' no método atual através da BeanUtils.setProperty() e verifica se o valor do atributo da anotação corresponde ao valor passado pelo String args[]. Caso seja, é utilizado novamente o BeanUtils.setProperty() para marcar como 'true' o atributo do campo analisado.
DIFICULDADES
A principal dificuldade que encontrei foi em associar a BeanUtils na inserção do valor na classe que fazia o mapeamento. Demorei boa parte do tempo mais para entender como era esse relacionamento entre as classes e saber que a BeanUtils faria a inserção na ParamClassTask1. Depois de entender isto, consegui fluir no exercício.


TASK 
2
IMPLEMENTAÇÃO
Basicamente estendi o conteúdo da Task 1, inserindo a verificação da TextValue dentro da isParameterPresent. Tomei esta decisão por inicialmente acreditar que poderia reaproveitar algum laço de repetição ou verificação - e que as duas anotações não fossem independentes uma da outra. Em questão de processo, as duas fazem uma análise parecida. A principal diferença está em pegar o TextValue e inserir nas funções mapeadas. Para pegar o conteúdo do TextValue, foi feito uma verificação interna da string em que: se um conjunto de caracteres estiver entre dois caracters com um - antes (e ele não tiver um -) ou estiver entre um - até o tamanho total da String então é considerado TextValue. Neste caso foi criado uma função String arg(String[] args, int i) para fazer este processo.
DIFICULDADES
A maior dificuldade foi saber como encaixar as funções. Devido a decisão de reaproveitar o laço, acabou que tive que gerar mais verificações dos campos declarados. Dependendo de como será a Task 3, esta decisão será revista.


TASK 
3
IMPLEMENTAÇÃO
A principal novidade nesta Task foi na criação de métodos que faziam as checagens necessárias para saber se um método ou classe tinha a anotação @Mandatory. Essas condicionais (basicamente uma por teste mais ou menos) estão inseridas antes e depois do "código base" das Tasks anteriores. A verificação da @Mandatory compõem o código da condicional em que o método tinha a anotação @TextValue. Algumas condicionais foram separadas para suportar a exceção ParameterReadingException.
DIFICULDADES
A decisão anterior de aproveitar o laço (como comentado no questionário da Task 2) se mostrou falho, pois nesta Task a anotação @TextValue era independente da @isParamenterPresent, o que se mostrou necessário remodelar o código e separar em duas condicionais: se o método continha a @isParamenterPresent ou a @TextValue. Se tinha a @TextValue, verificava se tinha uma @Mandatory. Outra dificuldade foi encontrar uma forma mais eficiente de verificar se nos argumentos continham todos os métodos @Mandatory. Não sei se foi eficiente, porém foi tomado a decisão de fazer esta verificação por último.


TASK 
4
IMPLEMENTAÇÃO
A princípio do mesmo modo que a Tarefa 3. De fato, o corpo de comparações e laços chaves do código para a @NumericValue foi a mesma para a @TextValue. A principal diferença foi na inserção de condicionais para verificar o tipo do argumento, e realizar a conversão entre String para o tipo específico. Também foi inserido uma nova verificação para os argumentos (checkStringArg), que verifica se ele começa com um - ou não. Outra mudança foi no método checkMandatoryMissing, onde foi desconsiderado a necessidade de verificação da anotação e deixado mais genérico para ser usado também para @NumericValue.
DIFICULDADES
Nesta tarefa, a maior dificuldade foi descobrir porque um argumento null estava passando pela condicional if (numericField.getAnnotation(NumericValue.class).toString().contains("name="+args[i].substring(1))) e dava positivo em todos os testes referentes ao throw Exception, mas 2 que davam erro/ficava vermelho eram sobre comparações com assertEquals. Percebi depois que aceitava porque o args[i].substring(1) era null, desta forma entrava em todas as anotações. Então, quando dava algum problema, entrava em um throw e parecia que tinha funcionado. Depois inseri um !args[i].substring(1).isEmpty e funcionou.


TASK 
5
IMPLEMENTAÇÃO
No geral, as principais mudanças foram no 'else' da anotação @TextValue para inserir a verificação da @ParameterLegth. Se possuir a anotação, verifica se a string está entre os parâmetros min() e max() - se não estiver, dá uma exceção. Também foi criado um método checkFormatWithNumbers() que verifica o formato da string pela anotação @ParameterFormat. Foi optado por criar um método porque ele será utilizado quando houver apenas a anotação @ParameterFormat, e também quando estiver atrelada com @TextValue. A checkFormatWithNumbers() recebe como parâmetro o vetor de String de argumentos (args), o campo (Field), a paramInstance e a posição no vetor do argumento (um inteiro). No método, verifica o regex da string e se estiver dentro do formato, insere através da BeansUtils. Se não, dá uma exceção. 
DIFICULDADES
Não foi encontrado nenhuma dificuldade relevante pra discussão neste momento (além que eu esqueci do RUNTIME...). Porém, tive que alterar de alguns métodos, como da condicional else if(field.isAnnotationPresent(TextValue.class)) porque percebi que havia redundância nas verificações.


TASK 
6
IMPLEMENTAÇÃO
Acrescentei condicionais dentro do escopo do código da anotação @NumericValue, se o valor do argumento era maior que o atributo max da @ParameterRange, ou menor que o min, ou o min maior que o max e se o min e max foram incluídos (neste caso, comparei se o min e o max eram iguais aos valores default Double.MIN_VALUE/MAX_VALUE). Também foi incluído uma condicional antes de aplicar o método BeanUtils.setProperty: para valores Short, Int e Long, se a anotação @ParameterPrecision está incluída joga uma exceção; já para Double e Float, verifica se a anotação @ParameterPrecision está incluída, se sim  verifica se o valor incluído para as casas decimais são negativos (se for, joga uma excessão), e verifica se o tamanho da casa decimal condiz com o que foi incluído como parâmetro da anotação @ParameterPrecision (realiza um solitário do argumento através do ponto flutuante e pega a segunda casa, e então verifica o tamanho da string pela função length).   
DIFICULDADES
A única "dificuldade" encontrada foi arrumar o erro da classe ParamClassTask6WithoutMinAndMax onde precisava definir os atributos da anotação @ParameterRange como default. Isto estava na explicação do exercício, eu que apenas não sabia definir.


TASK 
7
IMPLEMENTAÇÃO
Para o teste validValues, criei uma nova condicional específica para tratar a @CompositeParameter, que chama novamente o método map() passando como argumento o array args e o tipo do campo (neste caso, a ParamClassTask7WithAbstractComposite), e retorna para a variável gener do tipo genérico E. Com essa variável, uso a BeanUtils.setProperty para inserir o objeto deste Composite no atributo respectivo da classe. Todos os outros testes não precisaram de modificações no código (5 dos 6 testes passaram automaticamente).
DIFICULDADES
Tive que fazer uma modificação menor na verificação da anotação @TextValue, tendo que checar se o argumento tinha como valor inicial um traço ( - ). Precisei disto pois havia casos em que, como eu pego a substring(1) (ou seja, o valor depois do traço di argumento), se o argumento tivesse somente um caracter ele iria passar como uma string vazia, e como eu pego o campo que possui a anotação mapeada através da função contains havia casos em que retornava vazio e o programa pegava o primeiro campo da classe para mapear.


TASK 
8
IMPLEMENTAÇÃO
Criei um else final, o que significa que se nenhuma anotação prevista estiver sido encontrada, então espera-se que seja uma nova criada pelo usuário. Nisto, foi realizado um foreach para as anotações do determinado campo e um for para os argumentos. Nisto, é criado um objeto genérico Object que recebe uma nova instância da classe determinada na anotação @ParameterAnnotation. Então, cria uma variável readAnnotation do tipo Method, que vai receber este método, e será realizado um invoke() para inserir o valor. Caso a anotação contenha um ("name=") com o valor especificado no argumento (name=OTHER, MOK, por exemplo) será realizado o mesmo processo com a setParameter.
DIFICULDADES
Não há nada a comentar nesta tarefa.


TASK 
9
IMPLEMENTAÇÃO
Nas condicionais de se é a anotação @TextValue e @NumericValue coloquei uma condicional para verificar se o campo também é do tipo List.class e se o parâmetro genérico era do tipo esperado (@TextValue era String, e @NumericValue algum valor numérico). Caso o tipo do campo seja uma lista, chama a função arg() que recebe a String de argumentos, a posição no vetor e o parâmetro genérico, que representa o tipo do objeto. Agora, a função arg() cria uma lista genérica de objetos que verifica: se for uma String, simplesmente adiciona em uma lista; caso seja diferente, deduze que seja do tipo Number.class e então, através de reflexão, procura a função valueOf do tipo do objeto passado como parâmetro e faz o invoke. Depois, apenas realiza o BeanUtils para fazer o setProperty. Nota-se que a variável que recebe o retorno da função arg() é do tipo Object genérico, desta forma caso seja uma String uma List<String>, por exemplo, irá aceitar dependendo do tipo do campo mapeado.
DIFICULDADES
A maior dificuldade foi encontrar uma maneira de realizar a conversão de String para um tipo numérico de uma forma que aceitasse com que o objeto fosse genérico. Após muitos testes, percebi que se eu realizasse o getMethod() e depois o invoke() do tipo especificado no genericParameter seria uma maneira de deixar a função arg() mais genérica.


TASK 
10
IMPLEMENTAÇÃO
Criei uma condicional para caso a anotação @DataValeu estiver presente. Se sim, verifico se o tipo do campo é Date. Caso seja, é pego o valor passado pelo argumento da String. Depois, cria um objeto do tipo Date, que recebe um SimpleDateFormat passado como parâmetro o argumento da anotação @DateValue, e realiza um parse do argumento. Caso dê algum problema de formato, é jogado a exceção throw new ParameterReadingException("Exception: unparseable date format"); se não, é realizado o BeanUtils.setProperty().
DIFICULDADES
A única dificuldade foi encontrar um meio de especificar o formato para o objeto Date, mas assim que foi encontrado o SimpleDateFormat e seu método parse() a tarefa se tornou simples.


============================================
Ricardo Terra
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Implementei usando Container
DIFICULDADES
Tive problema com os testes de unidade. Contatei o Marco e ele me explicou que eu devia usar um Container já existente. Fiz as alterações e funcionou. Além disso, perdi um bom tempo com exceção relativa ao teste "nonBoleanParamMapped", já que a exceção retornada era de tipo diferente, mesmo sendo Runtime.


TASK 
2
IMPLEMENTAÇÃO
Simplesmente adicionei um novo tratamento para quando se tratava de String. Foi fácil, pois toda a estrutura já estava pronta.
DIFICULDADES
Esse foi bem tranquilo, acredito que o primeiro contato (tarefa 1) deu trabalho, mas nesse eu não tive dificuldades.


TASK 
3
IMPLEMENTAÇÃO
Basicamente criei uma nova anotação, no TextValueContainer coloquei um atributo que verifica se é mandatório e depois fiz poucos ajustes no ParamMapper. E também coloquei NeedsToHave e SearchOnEnclosingElements.
DIFICULDADES
Essa foi tranquila.


TASK 
4
IMPLEMENTAÇÃO
Criei uma nova anotação, modifiquei o ParamMapper para mapear essa anotação e fiz a lógica. Pronto!
DIFICULDADES
Uma coisa me chamou a atenção e por isso fiquei 20 minutos a mais nessa tarefa. Quando executo o Teste4 passa com sucesso, mas quando eu executo um suite de testes que criei AllTests, ele dá problema.


TASK 
5
IMPLEMENTAÇÃO
Criei as anotações. Coloquei algumas das restrições no ParamMapper, mas tive que criar um Validation para a questão do Min não poder ser maior que Max.
DIFICULDADES
Fiquei na dúvida no que dava para implementar facilmente e o que tinha que implementar com validator. Na verdade, existe validações a nível de valores dos campos e a nível de valores das anotações, o que me confude bastante.


TASK 
6
IMPLEMENTAÇÃO
Criei as anotações. Fiz uma alteração do validator do min max para ser genérico para string e números. Ajustei o NumericValueContainer. Fiz ajustes do ParamMapper para verificar os valores. E pronto!
DIFICULDADES
Sobre o ParameterRange que deve especificar pelo menos o Min ou o Max, eu não soube como fazer, mas tudo passou nos testes de unidade e optei por avançar para a Tarefa 7.


TASK 
7
IMPLEMENTAÇÃO
Criei a anotação. Coloquei Proihibits para Mandatory. Modifiquei o ParamContainer para criar chamar o map do objeto do tipo Composite quando encontrar um.
DIFICULDADES
Eu travei na hora de implementar o composite. O Marco me ajudou com a dica de que deveria apenas chamar o mapper novamente. Pronto! No entanto, terminei a tarefa com a falha de um teste. Parece um pouco inconsistente os testes validValues e withoutMandatory. A classe CompositeParamClassTask7 tem um @Mandatory em um campo @NumericValue. Isso é confuso para mim. E além do mais não está claro se não pode ter @Mandatory no atributo que tem @CompositeParameter ou se não pode ter nenhum @Mandatory dentro de uma classe que é @Composite. Confundi um pouco!


TASK 
8
IMPLEMENTAÇÃO
Tive sérios problemas. O Marco me ajudou. A ideia do processor não é fácil. Com um empurrão, consegui implementar. Tive que criar um novo Container, configurar o Processor, alterar a classe ParamMapper para incluir esse tipo e fazer a lógica de atribuição.
DIFICULDADES
Problema com a documentação. Entendi pouco o que era para fazer também. Se não fosse com a ajuda do Marco, não sei se conseguiria.


TASK 
9
IMPLEMENTAÇÃO
Fiz um AnnotationValidator. Deu errado e peguei um caminho errado usando processor. Depois vi meu erro e fiz um AnnotationValidator para String. Depois fiz o mesmo genérico para TextValue e NumericValue. Depois ajustei o TextValueContainer para pegar o field e ver o tipo. Depois fiz a lógica no ParamMapper e garanti que testes de unidade anteriores estava passando propriamente.
DIFICULDADES
nan


TASK 
10
IMPLEMENTAÇÃO
Essa foi tranquila. Criei um Container para DateValue. Criei um método do ParamMapperContainer que retorna todos os campos com essa anotação. Fiz os tratamentos em ParamMapper e pronto. Tudo funcionando. Inclusive executei todos os 10 testes de unidades e todos com sucesso.
DIFICULDADES
nan


============================================
Rodrigo de Souza
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Primeiramente usei o Container do Esfinge para armazenar os Fields anotados. Depois usei Reflection para acessar os métodos com o auxilio das informações do Container.
DIFICULDADES
A primeira dificuldade foi a impossibilidade de rodar os testes isoladamente (apenas um por vez). Eu fui obrigado a sempre rodar todos os testes sendo que eu queria na verdade rodar apenas um teste especifico. Na minha pesquisa por uma solução encontrei várias pessoas relatando que seria devido a versão do JUnit, porém mesmo alterando para a versão mais recente não consegui resolver.
Outro problema que eu não descobri como solucionar foi que por algum motivo o Esfinge está duplicando a "List<FieldContainer>". Ele está adicionando dois fields referente a annotation "@IsParameterPresent(name="A")", sendo que a classe "ParamClassTask1" possui apenas um field com essa annotation. Com a classe "InvalidParamClassTask1" isso não ocorre (pode ser por ela possuir apenas uma annotation).
Outra dificuldade foi que meus testes falhavam pois eu não havia percebido que os testes deveriam rodar com "boolean" e "Boolean". 
Creio que uma das dificuldades foi também a falta de experiência prática com o Esfinge.


TASK 
2
IMPLEMENTAÇÃO
Novamente utilizei o @AllFieldsWith para capturar todos os fields com a annotation TextValue. Em seguida utilizei a mesma solução da task 1 para setar os valores da classe. Desta vez incluir loops e avaliações de condições para atender todas as restrições.
DIFICULDADES
Investi um bom tempo um certo tempo tentando usar o Esfinge para utilizar um FieldContainer sendo uma abstração, um Interface. Não consegui fazer funcionar e devido ao tempo, acabei criando duas classe basicamente iguais.


TASK 
3
IMPLEMENTAÇÃO
Utilizei @ContainsAnnotation para saber quais parâmetros eram mandatórios. Por fim utilizei o mesmo código da task 2 para incluir as exceções requeridas.
DIFICULDADES
Foi necessário pausar o experimento por 30 minutos, pois o @ContainsAnnotation não estava funcionando e o mesmo causava uma exceção no Esfinge. Durante a pausa analisei com mais calma e descobri que o problema estava na convenção de nome.
Minha variável era "boolean isMandatory".
O Eclipse gerou os getters e setters da seguinte forma:
public boolean isParameterMandatory()
public void setParameterMandatory(boolean isParameterMandatory)

O Esfinge tentava invocar o método da seguinte forma, por exemplo:
PropertyUtils.setProperty(container, "isParameterMandatory", false);

Resumindo, quando existe uma variável boolean cujo o nome contém o prefixo "is", ao se gerar os getters e setters o Eclipse desconsidera o "is". Porém o Esfinge considera o "is", tentando invocar "setIsParameter(false)".


TASK 
4
IMPLEMENTAÇÃO
Utilizei a annotation @AllFieldsWith para obter todos os fields com a annotation @NumericValue. Em seguida eu reaproveitei o método da task 3 para construir a classe de retorno respeitando as restrições. Fiz algumas melhorias no código uma vez que os métodos estão ficando genéricos, ou seja, códigos muito semelhantes estão sendo utilizados em cada task. Sendo assim, criei uma classe chamada Utils que se encarrega de pegar os Métodos e Invoca-los se responsabilizando em descobrir qual o type correto dos parâmetros. Tentei deixar genérico os método principais que lidam com os valores dos Field Containers (getFieldValue, getNumericValue e setIsParameterPresent) mas não tive sucesso.
DIFICULDADES
Notei que os códigos das tasks passadas são bastante similares, sendo assim fiz modificações para utilizar em todos os testes os mesmos métodos, criando a classe Utils. Tentei fazer os mesmo com os métodos getFieldValue, getNumericValue e setIsParameterPresent, porém não obtive sucesso, pois ao se utilizar Interface para os fieldContainers o código não funciona, mais especificamente a annotation @AllFieldsWith deixa de funcionar. O que consumiu mais tempo foi a dificuldade em escolher um design adequado ao se lidar com vários tipos de classes dinamicamente, mesmo assim acho que eu poderia ter encontrado uma forma mais elegante se eu investisse mais tempo em minha pesquisa.


TASK 
5
IMPLEMENTAÇÃO
A implementação foi feita utilizando as propriedades das annotations do Esfinge, por exemplo, "ParameterLength" e "ParameterFormat". Os valores de suas propriedades foram utilizados em um métodos criado especialmente para realizar validações, e seguindo a mesma estrutura de loops e condicionais.
DIFICULDADES
Realizei uma refatoração, pois eu usava containers de fields diferentes para o "TextValue" e "NumericValue", ambos implementando a mesma interface, porém não é possível utilizar interfaces para tal. Então fiz a fusão dos atributos de ambas as classes em uma apenas, desta forma passei a utilizar o mesmo objeto no algoritmo principal. Realizei mudanças também a forma de validar valores de tasks anteriores, utilizando desta vez annotations do Esfinge, por exemplo, @ValidFieldTypes. Tive dificuldade na execução dos testes, onde eles eram bem sucedidos vezes sim vezes não. Fiz contato via e-mail e foi resolvido. Agora todo o código está funcionando perfeitamente. Acredito que de agora em diante irá acelerar a conclusão das futuras tasks.


TASK 
6
IMPLEMENTAÇÃO
Utilizei as validações com annotations do Esfinge @NeedsToHave, @ValidFieldTypes e @MinValue que exige nenhum esforço de implementação de tais regras. No meu método inclui um condicional (if) para checar se é um valor numérico e assim implementar as validações conforme especificado.
DIFICULDADES
Após a atualização da versão do Esfinge o desenvolvimento se tornou realmente rápido, devido também a familiarização com o framework. Nesta Task não tive nenhum problema.


TASK 
7
IMPLEMENTAÇÃO
Foi implementado um novo método chamado "getCompositeValue" na classe "ParamMapper". Este método é responsável por acessar os métodos get e set do field composite, realizando as validações. Se validado, o método faz uma chamada recursiva na própria classe "ParamMapper", desta vez passando a classe do composite e o resultado é utilizado no método set.
DIFICULDADES
Não tive nenhuma dificuldade especifica. Fiquei um pouco confuso sobre o que deveria ser feito e qual seria o melhor design a ser implementado. Porém no final da atividade acabou sendo uma implementação mais simples do que eu estava imaginando.
Experimente fazer uso da annotation "@ToValidate()", porém não funcionou e acabei mudando de estratégia. Porém na utilização do "@ToValidate()" notei que a documentação esta desatualizada. Ela apresenta o uso como "@ToValidate(value = Validator.class)", porém o uso na versão atual do Framework é "@ToValidate(Validator.class)".
Acabei fazendo uma busca na documentação a procura de annotations que pudessem ser uteis. Uma observação que gostaria de fazer é sobre a explicação do uso da annotation "@VolatileFieldOnly" que achei um pouco confusa e sem um exemplo que ajudasse no entendimento.


TASK 
8
IMPLEMENTAÇÃO
Foi implementado um novo método para processar as annotation customizadas. Foi implementado um único método para todos os casos de testes utilizando reflection. Foi utilizada a annotation @SearchInsideAnnotations na definição da annotation @ParameterAnnotation afim de usa-la como ponto de partida para as lógicas desenvolvidas.
DIFICULDADES
Durante boa parte do inicio da Task tive dificuldade de entender e definir um design para a implementação. Fiz uma pausa para estudar melhor o problema e pensar em um design. Além disso, tive dificuldade com os métodos de reflexão, já que o meu método (setCustomAnnotation) estava sendo desenvolvido de forma a ser independente das Annotation customizadas (dentro do package de teste). Também foi necessário fazer uma interrupção, já que a Task levou muito mais tempo do que o esperado.


TASK 
9
IMPLEMENTAÇÃO
A principio foi realizada algumas melhorias no código existente.
Foi adicionado List como um tipo válido para as annotation. Foi implementado um método para captura do tipo do parâmetro do generics, que por sua vez é utilizado no código de invocação do método setter.
O método "invokeMethod" da classe Utils foi modificado para tratar os métodos com tipo de argumento List.
DIFICULDADES
Logo no inicio da tarefa fiz uma pausa pois identifiquei algumas melhorias para aplicar no código.
Levei um certo tempo para encontrar as técnicas de implementação de ações que meu algoritmo exigia, por exemplo, converter String para um tipo de numérico não conhecido.


TASK 
10
IMPLEMENTAÇÃO
Foi incluído um novo filed no container com a annotation @AllFieldsWith(DateValue.class), este field recupera os valores do nome e formato definidos na annotation.
O código principal na classe ParamMapper foi modificado para tratar os field com a annotation DateValue. Por fim, o código responsável por fazer a invocação do método setter foi modificado para lidar com o tipo Date. Deste modo, as validações foram feitas ao se fazer os tratamentos de exceções.
DIFICULDADES
Não tive nenhuma dificuldade, fiz apenas consultas padrões sobre as APIs e sintaxes.


============================================
Wendel Silvério
Usando Esfinge Metadata
TASK 
1
IMPLEMENTAÇÃO
Verifiquei a documentação sobre o Esfinge Metadata no site (http://esfinge.sourceforge.net/Metadata.html). Tentei implementar o primeiro exemplo do Metadata Reader porém descobri que era aplicado somente a classe e não aos atributos. Consegui resolver o problema quando utilizei o @ProcessFields da mesma maneira apresentada na seção de Anotações avançadas. Após a criação correta do @ContainerFor, foi necessário atribuir os valores por reflexão e todos os testes passaram.
DIFICULDADES
Demorei a maior parte do tempo para entender o contexto do @ContainerFor, mas depois que descobri resolvi os testes rapidamente.


TASK 
2
IMPLEMENTAÇÃO
Criei dois atributos para a nova annotation (TextValue), substituí a lista de parâmetros por um map com o parâmetro e o valor passado e criei um tratamento separado para a annotation criada.
DIFICULDADES
Tentei criar um FieldContainer genérico para mais de uma annotation porém não consegui que interpretasse mais de uma annotation, então para solucionar este problema, criei atributos novos para a nova annotation.


TASK 
3
IMPLEMENTAÇÃO
Adicionei a validação de mandatory para atributo e classe no local onde o valor é preenchido no objeto
DIFICULDADES
Nenhuma dificuldade encontrada


TASK 
4
IMPLEMENTAÇÃO
Criei os atributos na classe FieldContainer para a anotação @NumericValue e criei um bloco de código para tratamento dos atributos anotados com @NumericValue na classe ParamMapper.
DIFICULDADES
Nenhuma dificuldade em relação ao uso da API


TASK 
5
IMPLEMENTAÇÃO
Implementei um requisito por vez e a cada conclusão eu executava os testes unitários.
DIFICULDADES
Tive dificuldade ao realizar os testes unitários que estavam variando a cada execução mesmo sem alterar o código. Enviei e-mail para o Marco e ele informou a nova versão do Esfinge Metadata com o problema corrigido. Após o ajuste da versão realizei a conclusão dos testes rapidamente.


TASK 
6
IMPLEMENTAÇÃO
Adicionei as informações das novas anotações na classe 'FieldContainer' e criei as condições no método 'readParameters' da  classe 'ParamMapper' de acordo com as regras descritas no experimento.
DIFICULDADES
Nenhuma dificuldade encontrada.


TASK 
7
IMPLEMENTAÇÃO
Adicionei a verificação se a anotação @CompositeParameter existe na classe FieldContainer, adicionei as condições no método readParameters da classe ParamMapper conforme especificado na task e realizei a verificação recursiva dos atributos compostos.
DIFICULDADES
Nenhuma dificuldade


TASK 
8
IMPLEMENTAÇÃO
Apliquei o @CustomReader para obter os processors para utilização na classe ParamMapper.
DIFICULDADES
A dificuldade que tive foi entender o funcionamento do Processor, para entender realizei várias implementações dos exemplos do site e da task.


TASK 
9
IMPLEMENTAÇÃO
Eu precisava colocar o código que trata de um unico valor dentro de um loop para ser executado para cada valor da lista.
DIFICULDADES
A maior dificuldade foi manter as validações de outras anotações que eram validadas por valor.


TASK 
10
IMPLEMENTAÇÃO
Inclui atributos da anotação @DateValue e dos seus parâmetros na classe ParamMapper
DIFICULDADES
Nenhuma dificuldade


